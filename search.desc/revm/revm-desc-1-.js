searchState.loadedDescShard("revm", 1, "Transaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nOutput of a transaction execution.\nOverflow payment in transaction.\nPrecompile error.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction validation error.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nThe specification ID.\nSpecification IDs and their activation block.\nReturns <code>true</code> if the given specification ID is enabled in …\nAccountInfo account information.\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\nStructure used for EIP-1153 transient storage.\nAccount balance.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nAccount nonce.\nOriginal value of the storage slot.\nPresent value of the storage slot.\nAccount status flags.\nStorage cache\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nSimple interface to the <code>Keccak-256</code> hash function.\nAn Ethereum address, 20 bytes in length.\n32-byte fixed byte-array type.\nThe input length is not exactly 192 bytes.\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nThe proof verification failed.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nSimilar to Standard but takes reference to environment.\nContains the error value\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nA log consists of an address, and some log data.\nContains the success value\nCatch-all variant for other errors.\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturns reference of address.\nThe address which emitted this log.\nReturns an iterator over the precompiles addresses.\nReturns the precompiles addresses as a set.\nReturns precompiles for Berlin spec.\nOutput bytes.\nReturns precompiles for Byzantium spec.\nCall the precompile with the given input and gas limit and …\nCall the precompile with the given input and gas limit and …\nReturns precompiles for Cancun spec.\nIs the given address a precompile.\nThe log data.\nExtends the precompiles with the given precompiles.\nDisable kzg precompile. This will return Fatal error on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the appropriate precompile Spec for the primitive …\nGas used by the precompile.\nReturns the precompile for the given address.\nReturns the precompile for the given address.\nReturns precompiles for Homestead spec.\nReturns inner HashMap of precompiles.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the type and returns all precompile addresses.\nIs the precompiles list empty.\nReturns true if the error is out of gas.\nReturns precompiles for Istanbul spec.\nReturns the precompiles for the latest spec.\nReturns the number of precompiles.\nReturns the precompiles for the given spec.\nReturns new precompile output with the given gas used and …\nCreate a new stateful precompile.\nCreate a new mutable stateful precompile.\nReturns an other error with the given message.\nReturns precompiles for Prague spec.\nReturns reference of precompile.\nConst function for making an address by concatenating the …\nreference: https://eips.ethereum.org/EIPS/eip-152 input …\ngot IV from: …\nSIGMA from spec: …\nG function: https://tools.ietf.org/html/rfc7693#section-3.1\nReturns the BLS12-381 precompiles with their addresses.\nBLS12_G1ADD precompile address.\nEIP-2537 BLS12_G1ADD precompile.\nBLS12_G1MSM precompile address.\nDiscounts table for G1 MSM as a vector of pairs …\nEIP-2537 BLS12_G1MSM precompile.\nBLS12_G2ADD precompile address.\nEIP-2537 BLS12_G2ADD precompile.\nBLS12_G2MSM precompile address.\nEIP-2537 BLS12_G2MSM precompile.\nBLS12_MAP_FP2_TO_G2 precompile address.\nEIP-2537 BLS12_MAP_FP2_TO_G2 precompile.\nBLS12_MAP_FP_TO_G1 precompile address.\nEIP-2537 BLS12_MAP_FP_TO_G1 precompile.\nBLS12_PAIRING precompile address.\nEIP-2537 BLS12_PAIRING precompile.\nInput length for the add operation. <code>ADD</code> takes two …\nInput length for the multiplication operation. <code>MUL</code> takes …\nPair element length. <code>PAIR</code> elements are composed of an …\nCreates a new <code>G1</code> point from the given <code>x</code> and <code>y</code> coordinates.\nReads a single <code>Fq</code> from the input slice.\nReads the <code>x</code> and <code>y</code> points from the input slice.\nFatal precompile that returns Fatal error on precompile …\nDisable kzg precompile. This will return Fatal error on …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new fatal precompile\nCreate a new stateful fatal precompile\nComputes the RIPEMD-160 hash of the input data.\nComputes the SHA-256 hash of the input data.\nThe base cost of the operation.\nThe cost per word.\nTakes the input bytes, copies them, and returns it as the …\n…\n<code>VERSIONED_HASH_VERSION_KZG ++ sha256(commitment)[1..]</code>\nRun kzg point evaluation precompile.\nSee: https://eips.ethereum.org/EIPS/eip-198 See: …\nAccessList as defined in EIP-2930\nA list of addresses and storage keys that the transaction …\nAccess list is not supported for blocks before the Berlin …\nAccountInfo account information.\nAn Ethereum address, 20 bytes in length.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\n32-byte fixed byte-array type.\nControls the maximum rate of change for blob gas price.\nControls the maximum rate of change for blob gas price …\nEIP-2935: Serve historical block hashes from state\nEIP-2935: Serve historical block hashes from state\nNumber of block hashes that EVM can access in the past …\nBlob transaction can’t be a create transaction. <code>to</code> must …\nStructure holding block blob excess gas and it calculates …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nThe block environment.\nState of the <code>Bytecode</code> analysis.\nEOF decode errors.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nA transaction that calls a contract or transfer.\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nEVM configuration.\nConfiguration environment with the chain spec id.\nused to mark account as cold\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nA transaction that creates a contract.\nCreate scheme of <code>CREATE2</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCreate scheme.\nWhen account is newly created we will not access database …\nCustom trusted setup.\nCustom error.\nDatabase error.\nDefault mainnet trusted setup\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEOF Subroutine stack overflow\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEIP-7702 delegated bytecode\nEIP-7702 decode error\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nEVM environment configuration.\nSimilar to Standard but takes reference to environment.\nKZG Settings that allow us to specify a custom trusted …\nEvm environment with the chain spec id.\nEVM Object Format (EOF) container.\nEthereum Object Format\nEOF decode error\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\nContains the error value\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nA byte array of fixed length (<code>[u8; N]</code>).\nGas consumption of a single data blob (== blob byte size).\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHandler configuration fields. It is used to configure the …\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nHeader validation error.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\nIndicates a failed recovery attempt where no valid address …\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nTransaction validation error.\nA map of valid <code>jump</code> destinations.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nStores the setup and parameters needed for computing KZG …\nTransaction account does not have enough amount of ether …\nThe bytecode has been analyzed for valid jump destinations.\nLegacy analyzed\nNo analysis has been performed.\nWhen account is loaded but not touched or interacted with. …\nused only for pre spurious dragon hardforks where existing …\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nMinimum gas price for data blobs.\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nOutput of a transaction execution.\nOverflow payment in transaction.\nThe address of precompile 3, which is handled specially in …\nPrecompile and its handlers.\nPrecompile error.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\n<code>prevrandao</code> is not set for Merge and above.\nAn Ethereum ECDSA signature.\nWhen using the EIP-1559 fee model introduced in the London …\nDo not perform bytecode analysis.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nThe specification ID.\nIf account is marked for self destruction.\nA signed EIP-7702 authorization.\nSpecification IDs and their activation block.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nOnly when account is marked as touched we will save it to …\nTransaction destination\nTransaction validation error.\nStructure used for EIP-1153 transient storage.\nThe transaction environment.\nThe <code>to</code> field of a transaction. Either a target address, or …\n256-bit unsigned integer type, consisting of 4, 64-bit …\nOnly supported version is version 0x00.\nFirst version of the blob.\nIndicates a successfully recovered authority address.\nArray of Zero bytes.\nArray of Zero bytes.\nA list of addresses and storage keys that the transaction …\nAdds an address to the access list and returns <code>true</code> if the …\nReturns an optional address if valid.\nGet the <code>address</code> for the authorization.\nReturn the address of the delegated contract.\nReturns the created address, if any.\nAccount addresses that would be loaded at the start of …\nThe address of the authorization.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nGet a flags value with all known bits set.\nReturns the byte-array representation of this signature.\nReturns a mutable slice containing the entire array. …\nGet the raw bytes of the jump map\nReturns a slice containing the entire array. Equivalent to …\nReturns an optional address based on the current state of …\nList of authorizations, that contains the signature that …\nConverts a sequence of string literals containing …\nAccount balance.\nThe base fee per gas, added in the London upgrade with …\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nReturns the blob target and max count for the given spec …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCreate boxed Env.\nReturns a reference to the bytecode.\nReturns a reference to the bytecode.\nReturns bytes\nOutput bytes.\nConverts a sequence of string literals containing …\nReturns bytes slice\nCalculates the blob gas price from the header’s excess …\nCalculates the EIP-4844 <code>data_fee</code> of the transaction.\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nCalculates the maximum [EIP-4844] <code>data_fee</code> of the …\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nGet the <code>chain_id</code> for the authorization.\nThe chain ID of the authorization.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nReturns an iterator over the storage slots that have been …\nResets environment to default values.\nClears environment and resets fields to default values.\nClears environment and resets fields to default values.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\nReturn bytecode hash associated with this account. If …\ncode hash,\nCoinbase or miner or address that created and signed the …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nConcatenate two <code>FixedBytes</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nReturns <code>true</code> if no bits are set.\nWhether all set bits in a source flags value are also set …\nChecks if the access list contains the specified address.\nChecks if a specific storage slot within an account is …\nCreates a new <code>Bytes</code> instance from a slice by copying it.\nReturns a copy of this account with the <code>Bytecode</code> removed. …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nComputes the <code>create</code> address for this address and nonce:\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the <code>CREATE2</code> address of a smart contract as …\nReturns a slice of the data section.\nReturns the output data of the execution output.\nThe data of the transaction.\nThe plain data.\nThe log data.\nReturns a slice of the raw bytes. If offset is greater …\nDecode EOF from raw bytes.\nDecode EOF that have additional dangling bytes. Assume …\nDecode an RLP-encoded VRS signature. Accepts <code>decode_parity</code> …\nThe intersection of a source flags value with the …\nThe difficulty of the block.\nCalculates the effective gas price of the transaction.\nReturn empty authorization list.\nCreates a new empty log.\nCreates a new empty log.\nGet a flags value with all bits unset.\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns <code>true</code> if the given specification ID is enabled in …\nSlow encode EOF bytes.\nEvm environment.\nReturn reference to the EOF if bytecode is EOF.\nThe excess blob gas of the block.\nReturns <code>true</code> if the account is not empty.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nConverts a sequence of string literals containing …\nReturns an iterator over the list’s addresses and …\nConverts the list into a vec, expected by revm\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>TxKind::Call</code> with the <code>Some</code> address, <code>None</code> …\nCreates a <code>TxKind::Call</code> with the given address.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nParses a signature from a byte slice, with a v value\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCalculate this block excess gas and price from the parent …\nConverts an ECDSA signing key to its corresponding …\nConverts an ECDSA verifying key to its corresponding …\nInstantiate by hashing public key bytes.\nCreates a <code>PrimitiveSignature</code> from the serialized <code>r</code> and <code>s</code> …\nInstantiate from a signature and recovery id\nConstruct a jump map from raw bytes\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>.\nCreates a new <code>Bytes</code> from a static slice.\nCreates an Ethereum address from an EVM word’s upper 20 …\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nReturns the gas used.\nGas used by the precompile.\nReturn set KZG settings.\nReturn <code>blob_excess_gas</code> header field. See EIP-4844.\nSee EIP-4844 and <code>crate::calc_blob_gasprice</code>.\nSee EIP-4844, <code>Env::calc_data_fee</code>, and …\nHandler configuration fields.\nHandler configuration fields.\nReturns <code>true</code> if account has no nonce and code.\nCalculate hash of the bytecode.\nMacro for converting sequence of string literals …\nBalance, nonce, and code.\nReturns the inner <code>Authorization</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the output data of the execution output.\nConsumes the type and returns an iterator over the list’…\nConsumes the type and converts the list into a vec, …\nReturns the inner ECDSA signature.\nConsumes <code>self</code> and returns the logs if execution is …\nConsumes the type and returns the output data of the …\nSplits the authorization into parts.\nRecover the authority and transform the signed …\nReturns recovered authorizations list.\nConvert to a signed authorization by adding a signature.\nLeft-pads the address to 32 bytes (EVM word size).\nWhether all known bits in this flags value are set.\nReturns true if the transaction is a contract call.\nReturns true if the present value differs from the …\nRepresents if the storage slot is cold.\nReturns true if the transaction is a contract creation.\nIs account newly created in this transaction.\nReturns true if bytecode is EIP-7702.\nReturns whether the bytecode is empty.\nReturns true if the authorization list is empty.\nIs account empty, check if nonce and balance are zero and …\nWhether all bits in this flags value are unset.\nReturns if an account is empty.\nReturns true if the code hash is the Keccak256 hash of the …\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns true if bytecode is EOF.\nReturns false if bytecode can’t be executed in …\nReturns true if execution result is a Halt.\nReturns true if the authority is invalid.\nIs account loaded as not existing from database This is …\nReturns <code>true</code> if the optimism feature is enabled and flag …\nIs account marked for self destruct.\nReturns if transaction execution is successful. 1 …\nIf account status is marked as touched.\nReturns true if the authority is valid.\nCheck if <code>pc</code> is a valid jump destination.\nTrue if valid, false otherwise.\nReturns <code>true</code> if no bits are set.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nJumptable of analyzed bytes.\nSimple interface to the <code>Keccak-256</code> hash function.\nKZG Settings for point evaluation precompile. By default, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nReturn jump table if bytecode is analyzed\nReturns the length of the original bytes.\nReturns length of the authorization list.\nReturns the size of this array in bytes.\nReturns the size of this byte array (<code>N</code>).\nIf some it will effects EIP-170: Contract code size limit. …\nInitializes a trusted setup from <code>FIELD_ELEMENTS_PER_BLOB</code> …\nLoads the trusted setup parameters from a file. The file …\nLoads the trusted setup parameters from a file.\nReturns the logs if execution is successful, or an empty …\nMaps a <code>DBError</code> to a new error type using the provided …\nMark account as cold.\nMarks the storage slot as cold.\nMark account as newly created.\nMark account as self destructed.\nMark account as touched\nMark account as warm and return true if it was previously …\nMarks the storage slot as warm and returns a bool …\nReturns max code size from <code>Self::limit_contract_code_size</code> …\nThe max fee per blob gas.\nCreates a new EOF container from the given body.\nCreate new analyzed bytecode.\nCreates a new EIP-7702 bytecode with the given address.\nCreates new <code>HandlerCfg</code> instance.\nReturns new instance of <code>CfgEnvWithHandlerCfg</code> with the …\nReturns new <code>EnvWithHandlerCfg</code> instance.\nWraps the given byte array in this type.\nCreates a new instance by calculating the blob gas price …\nWraps the given byte array in <code>FixedBytes</code>.\nCreates a new empty <code>Bytes</code>.\nCreates a new log.\nCreates a new log.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new <em>unchanged</em> <code>EvmStorageSlot</code> for the given value.\nCreate new checked bytecode.\nCreates a new <em>changed</em> <code>EvmStorageSlot</code>.\nCreates a new EIP-7702 <code>Bytecode</code> from <code>Address</code>.\nCreates a new log from an deserialized event.\nCreates a new log.\nCreates a new legacy <code>Bytecode</code>.\nCreate new account and mark it as non existing.\nCreates a new raw <code>Bytecode</code>.\nCreates a new EIP-7702 bytecode or returns None if the raw …\nCreates a new raw <code>Bytecode</code>.\nCreates a new signed authorization from raw signature …\nInstantiate without performing recovery. This should be …\nCreates a new log, without length-checking. This allows …\nCreates a new log.\nTakes <code>CfgEnvWithHandlerCfg</code> and returns new …\nReturns new <code>CfgEnvWithHandlerCfg</code> instance with the chain …\nReturns new <code>EnvWithHandlerCfg</code> instance with the chain spec …\nGet the <code>nonce</code> for the authorization.\nThe nonce for the authorization.\nThe nonce of the transaction.\nAccount nonce.\nNormalizes the signature into “low S” form as …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe number of ancestor blocks of this block (block height).\nOriginal bytes without padding.\nReturns the original bytecode as a byte slice.\nOriginal bytes without padding.\nReturns a reference to the original bytecode.\nOriginal bytes length.\nReturns the original value of the storage slot.\nOriginal value of the storage slot.\nReturns the output data of the execution.\nParse an Ethereum address, verifying its EIP-55 checksum.\nParses the contents of a KZG trusted setup file into a …\nBytecode that is created with CREATE/CREATE2 is by default …\nReturns the current value of the storage slot.\nPresent value of the storage slot.\nThe output of the randomness beacon provided by the beacon …\nReturns the signature <code>r</code> value.\nReturns the <code>r</code> component of this signature.\nReturn raw EOF bytes.\nReturn the raw bytecode with version MAGIC number.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecover the authority for the authorization.\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nReturns iterator of recovered Authorizations.\nThe intersection of a source flags value with the …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new <code>FixedBytes</code> where all bytes are set to <code>byte</code>.\nReserialize the data.\nStatus of execution\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nReturns the signature <code>s</code> value.\nReturns the <code>s</code> component of this signature.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTakes <code>blob_excess_gas</code> saves it inside env and calculates …\nSets the blob target and max count over hardforks.\nSet the topic list, truncating to 4 topics.\nSet the topic list, without length-checking. This allows …\nGets the <code>signature</code> for the authorization. Returns …\nComputes the signature hash used to sign the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nReturns len of the header and body in bytes.\nCalculates a heuristic for the in-memory size of this …\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nReturns the specification id.\nSpecification identification.\nConsumes the log data, returning the topic list and the …\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nState that got updated\nCheck if account is empty and check if empty state before …\nAccount status flags.\nStorage cache\nKeys of storage that would be loaded at the start of …\nReturns the inner <code>Authorization</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTake bytecode from account. Code will be set to None.\nThe timestamp of the block in seconds since the UNIX epoch.\nReturns the address of the contract that will be called or …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into …\nReturns the inner ECDSA signature.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nGet the topic list.\nGet the topic list, mutably. This gives access to the …\nGet a mutable reference to the topic list. This allows …\nThe destination of the transaction.\nParses a raw signature which is expected to be 65 bytes …\nReturns the <code>SpecId</code> for the given <code>u8</code>.\nConfiguration of the transaction that is being executed.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUnmark created flag.\nUnmark account as self destructed.\nUnmark the touch flag.\nReturns the recovery ID as a <code>bool</code>.\nValidate the block environment.\nValidate transaction data that is set inside ENV and …\nValidate transaction against state.\nThe value sent to <code>transact_to</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new <code>FixedBytes</code> with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nStrip the <code>Bytecode</code> from this account and drop it. This is …\nWrite R and S to an RLP buffer in progress.\nWrite the VRS to the output.\nReturns the signature parity value.\nSalt.\nHalting will spend all the gas, and will be equal to …\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n16-byte fixed byte-array type.\n20-byte fixed byte-array type.\n32-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\nThe size of this integer type in bits.\nNumber of bits.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe size of this integer type in bytes. Note that some …\nThe size of this integer type in bytes. Note that some …\nThe error type that is returned when conversion to or from …\nA block hash.\nA block number.\nA block timestamp.\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nChain identifier type (introduced in EIP-155).\nA transaction that creates a contract.\nExplicit V value. May be EIP-155 modified.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nSimple <code>Keccak-256</code> hasher.\nThe size of this integer type in 64-bit limbs.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nBit mask for the last limb.\nThe largest value that can be represented by this integer …\nThe maximum value.\nThe smallest value that can be represented by this integer …\nThe minimum value.\nMinus one (multiplicative inverse) of this type.\nLess than zero.\nNon-EIP155. 27 or 28.\nOne (multiplicative identity) of this type.\nThe parity of the signature, stored as either a V value …\nParity flag. True for odd.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nAn Ethereum ECDSA signature.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nSolidity contract functions are addressed using the first …\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe <code>to</code> field of a transaction. Either a target address, or …\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n128-bit unsigned integer type, consisting of 2, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\nThe value zero. This is the only value that exists in all …\nArray of Zero bytes.\nArray of Zero bytes.\nZero (additive identity) of this type.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nAccrues the input into the bloom filter.\nAccrues the input into the bloom filter.\nIngests a log into the bloom filter.\nIngests a raw log into the bloom filter.\nCompute $\\mod{\\mathtt{self} + \\mathtt{rhs}}_…\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nDouble precision logarithm.\nDouble precision decimal logarithm.\nDouble precision binary logarithm.\nConstruct from double precision binary logarithm.\nArithmetic shift right by <code>rhs</code> bits.\nReturns references to the address and selector of the …\nReturns the byte-array representation of this signature.\nReturns the sign character.\nConversion to i16 with overflow checking.\nConversion to i32 with overflow checking.\nConversion to i64 with overflow checking.\nConversion to i8 with overflow checking.\nConversion to isize with overflow checking.\nAccess the underlying store as a little-endian bytes.\nAccess the underlying store as a little-endian bytes with …\nAccess the underlying store as a little-endian slice of …\nAccess the underlying store as a mutable little-endian …\nView the array of limbs.\nView the array of limbs.\nAccess the array of limbs.\nReturns the checksum of a formatted address.\nReturns the checksum of a formatted address.\nConversion to u16 with overflow checking.\nConversion to u32 with overflow checking.\nConversion to u64 with overflow checking.\nConversion to u8 with overflow checking.\nConversion to usize with overflow checking.\nArithmetic shift left operation. Computes <code>self &lt;&lt; rhs</code>, …\nArithmetic shift right operation. Computes <code>self &gt;&gt; rhs</code> …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nReturns whether a specific bit is set.\nReturns whether a specific bit is set.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nLength of the number in bits ignoring leading zeros.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nReturn the least number of bits needed to represent the …\nConverts a sequence of string literals containing …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nLength of the number in bytes ignoring leading zeros.\nConverts a sequence of string literals containing …\nReturns the chain ID associated with the V value, if this …\nReturns the chain ID associated with the V value, if this …\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nComputes <code>self + rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nComputes <code>self / rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nConstruct a new integer from little-endian a slice of …\nCreates a <code>Signed</code> from an absolute value and a negative …\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nComputes <code>self * rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, returning <code>None</code> unless <code>self == 0</code>.\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nRaises self to the power of <code>exp</code>.\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nComputes <code>self % rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked left shift by <code>rhs</code> bits.\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked right shift by <code>rhs</code> bits.\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nComputes <code>self - rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nClone the inner item.\nCompile-time version of <code>contains</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nEquality at compile-time.\nReturns true if this bloom filter is a possible superset …\nReturns true if this bloom filter is a possible superset …\nTrue if the bloom filter contains a log with given address …\nTrue if the bloom filter contains a log with given address …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns a reference to the underlying data.\nThe plain data.\nThe log data.\nReturns a mutable reference to the underlying data.\nDecode an RLP-encoded VRS signature.\nComputes <code>self / rhs</code> rounding up.\nCalculates the quotient of Euclidean division of <code>self</code> by …\nComputes <code>self / rhs</code> and <code>self % rhs</code>.\nHash a message according to EIP-191 (version <code>0x01</code>).\nCreate <code>10**n</code> as this type.\nPad and squeeze the state.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nConverts a sequence of string literals containing …\nCalculates the checksum of an address into the buffer.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConstruct a new <code>Uint</code> from the value.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an Ethereum function from an address and selector.\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConstructs the <code>Signed</code> from digits in the base <code>base</code> in …\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConverts a big-endian byte array of size exactly …\nConverts a big-endian byte array of size exactly …\nCreates a new integer from a big endian slice of bytes.\nParses a signature from a byte slice, with a v value\nConvert from a decimal string.\nConvert from a hex string.\nConverts a little-endian byte array of size exactly …\nConvert from an array in LE format\nCreates a new integer from a little endian slice of bytes.\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a slice of …\nCoerces an unsigned integer into a signed one. If the …\nInstantiate from v, r, s.\nCreates a <code>Signature</code> from the serialized <code>r</code> and <code>s</code> scalar …\nInstantiate from a signature and recovery id\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nParse a string into a <code>Uint</code>.\nCreates an Ethereum function from an EVM word’s lower 24 …\nCompute the greatest common divisor of two <code>Uint</code>s.\n⚠️ Compute the greatest common divisor and the Bézout …\nReturns true if the signature is replay-protected by …\nReturns true if the signature is replay-protected by …\nGet the hash.\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nHex literal macro implementation.\nGet the inner item.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the inner bytes array.\nConsume the input, converting it to the hash.\nReturns the backing buffer.\nUnseal the inner item, discarding the hash.\nReturns the inner ECDSA signature.\nConvert to a array of limbs.\nConvert to a array of limbs.\nConsume and convert into a <code>LogData</code> object.\nDecompose into parts.\nReturns the signed integer as a unsigned integer. If the …\nSplits a Signed into its absolute value and negative flag.\nRight-pads the function to 32 bytes (EVM word size).\nCompute $\\mod{\\mathtt{self}^{-1}}_{\\mathtt{modulus}}$.\nComputes the inverse modulo $2^{\\mathtt{BITS}}$ of <code>self</code>, …\nInverts the parity.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns whether the sign is negative.\nDetermines if the integer is odd.\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns whether the sign is positive.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns true if the value is zero.\nReturns <code>true</code> if <code>self</code> is zero and <code>false</code> if the number is …\nSimple interface to the <code>Keccak-256</code> hash function.\nCompute the least common multiple of two <code>Uint</code>s or <code>None</code> if …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nReturns the size of this array in bytes.\nReturns the size of this array in bytes.\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nCompute the logs bloom filter for the given logs.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nSpecialised Bloom filter that sets three bits out of 2048, …\n<code>m3_2048</code> but with a pre-hashed input.\nRe-exports of map types and utilities.\nReturns the most significant 64 bits of the number and the …\nCompute $\\mod{\\mathtt{self} ⋅ \\mathtt{rhs}}_…\nMontgomery multiplication.\nCreates a new buffer.\nWraps the given byte array in this type.\nWraps the given byte array in this type.\nSeal the inner item.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new <code>Keccak256</code> hasher.\nSeal the inner item, by reference.\nSeal a reference to the inner item with some function.\nInstantiate without performing the hash. This should be …\nSeal the inner item with some function.\nCalculates the smallest value greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nNormalizes the signature into “low S” form as …\nAttempts to normalize the v value to a boolean parity …\nComputes the absolute value of <code>self</code>.\nCalculates $\\mod{\\mathtt{self} + \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> / <code>rhs</code>\nCalculates the quotient of Euclidean division …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nCreates a <code>Signed</code> from a sign and an absolute value. …\nCalculates the multiplication of self and rhs.\nCalculates <code>self</code> * <code>rhs</code>\nCalculates $\\mod{-\\mathtt{self}}_{2^{BITS}}$.\nNegates self, overflowing if this is equal to the minimum …\nRaises self to the power of <code>exp</code> and if the result would …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates <code>self</code> % <code>rhs</code>\nOverflowing Euclidean remainder. Calculates …\nLeft shift by <code>rhs</code> bits with overflow detection.\nShifts self left by <code>rhs</code> bits.\nRight shift by <code>rhs</code> bits with underflow detection.\nShifts self right by <code>rhs</code> bits.\nCalculates $\\mod{\\mathtt{self} - \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> - <code>rhs</code>\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCompute $\\mod{\\mathtt{self}^{\\mathtt{rhs}}}_…\nReturns the <code>r</code> component of this signature.\nDetermines the recovery ID.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\n⚠️ Compute $\\mod{\\mathtt{self}}_{\\mathtt{modulus}}$.\nCalculates the least nonnegative remainder of …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nReverses the order of bits in the integer. The least …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nLength of RLP V field encoding\nComputes the floor of the <code>degree</code>-th root of the number.\nShifts the bits to the left by a specified amount, <code>rhs</code>, …\nShifts the bits to the right by a specified amount, <code>rhs</code>, …\nReturns the <code>s</code> component of this signature.\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nComputes <code>self + rhs</code>, saturating at the numeric bounds …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, saturating at the numeric bounds …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating negation. Computes <code>-self</code>, returning <code>MAX</code> if …\nRaises self to the power of <code>exp</code>, saturating on overflow.\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating left shift by <code>rhs</code> bits.\nComputes <code>self - rhs</code>, saturating at the numeric bounds …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nExamples\nGet the hash.\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nSets a specific bit to a value.\nReturns the sign of self.\nDecompose into parts. Alias for <code>Self::into_parts</code>.\nConverts an EIP-155 V value to a non-EIP-155 V value.\nPanics\nReturns the address and selector of the function.\nReturns an iterator over the base <code>base</code> digits of the …\nReturns an iterator over the base <code>base</code> digits of the …\nConverts the <code>Uint</code> to a big-endian byte array of size …\nConverts <code>self</code> to a big-endian byte array of size exactly …\nConverts the <code>Uint</code> to a big-endian byte vector with leading …\nConverts the <code>Uint</code> to a big-endian byte vector of size …\nConvert to a decimal string.\nApplies EIP-155.\nConvert to a hex string.\nReturns the inner ECDSA signature.\nConverts the <code>Uint</code> to a little-endian byte array of size …\nConverts <code>self</code> to a little-endian byte array of size exactly\nConverts the <code>Uint</code> to a little-endian byte vector with …\nConverts the <code>Uint</code> to a little-endian byte vector of size …\nConvert into a <code>LogData</code> object.\nConvert to a parity bool, dropping any V information.\nReturns the checksum of a formatted address.\nReturn the corresponding u64 V value.\nReturns the number of trailing ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of leading zeros in the binary …\nParses a raw signature which is expected to be 65 bytes …\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nTries to create a <code>Vec</code> containing the arguments.\nCompute the two’s complement of this number.\nShortcut for <code>val.try_into().unwrap()</code>.\nShortcut for <code>self.try_into().unwrap()</code>.\nUnseal the inner item, discarding the hash. Alias for …\nComputes the absolute value of <code>self</code> without any wrapping …\nAbsorbs additional input. Can be called multiple times.\nCommon Ethereum utilities.\nReturns the recovery ID as a <code>u8</code>.\nCalculates the complete product <code>self * rhs</code> without the …\nApplies EIP-155 with the given chain ID.\nModifies the recovery ID by applying EIP-155 to a <code>v</code> value.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nModifies the recovery ID by dropping any [EIP-155] v …\nWrap a fixed-size byte array in a newtype, delegating all …\nWrapping absolute value. Computes <code>self.abs()</code>, wrapping …\nComputes <code>self + rhs</code>, wrapping around at the boundary of …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nComputes <code>self / rhs</code> rounding down.\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, wrapping around at the boundary of …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, wrapping around at the boundary of the …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, wrapping around at the …\nComputes <code>self % rhs</code>.\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nLeft shift by <code>rhs</code> bits.\nWrapping shift left. Computes <code>self &lt;&lt; rhs</code>, returning 0 if …\nRight shift by <code>rhs</code> bits.\nWrapping shift right. Computes <code>self &gt;&gt; rhs</code>, returning 0 if …\nComputes <code>self - rhs</code>, wrapping around at the boundary of …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nExamples\nWrite R and S to an RLP buffer in progress.\nWrite the V to an RLP buffer without using EIP-155.\nWrite the VRS to the output. The V will always be 27 or 28.\nReturn the y-parity as a boolean.\nReturn the y-parity as 0 or 1\nReturn the y-parity byte as 27 or 28, in the case of a …\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\nMacro for converting sequence of string literals …\nA correctly sized stack allocation for the formatted bytes …\nThe associated error which can be returned from parsing.\nTypes that can be decoded from a hex string.\nThe error type for decoding a hex string into <code>Vec&lt;u8&gt;</code> or …\nThe table of lowercase characters used for hex encoding.\nThe table of uppercase characters used for hex encoding.\nThe lookup table of hex byte to value, used for hex …\nAn invalid character was found. Valid ones are: <code>0...9</code>, …\nIf the hex string is decoded into a fixed sized container, …\nThe length of the buffer in bytes.\nRepresents an invalid value in the <code>HEX_DECODE_LUT</code> table.\nA hex string’s length needs to be even, as two digits …\nEncoding values as hex string.\nEncoding values as hex string.\nReturns a reference the underlying stack-allocated byte …\nReturns a reference to the underlying bytes.\nReturns a mutable reference the underlying stack-allocated …\nReturns a mutable reference to the underlying bytes.\nReturns an unsafe mutable pointer to the slice’s buffer.\nReturns a mutable reference to the underlying bytes casted …\nReturns a raw pointer to the buffer.\nReturns a reference to the underlying bytes casted to a …\nReturns a mutable reference to the underlying buffer, …\nReturns <code>true</code> if the input is a valid hex string and can be …\nReturns <code>true</code> if the input is a valid hex string.\nReturns <code>true</code> if the input is a valid hex string and can be …\nReturns <code>true</code> if the input is a valid hex string.\nDecode a hex string into a fixed-length byte-array.\nEncodes <code>input</code> as a hex string into a <code>Buffer</code>.\nPrint an array of bytes into this buffer.\nPrint an array of bytes into this buffer.\nDecodes a hex string into raw bytes.\nDecode a hex string into a fixed-length byte-array.\nDecode a hex string into a mutable bytes slice.\nDeserializes a hex string into raw bytes.\nEncodes <code>data</code> as a hex string using lowercase characters.\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result …\nEncode the hex strict representing <code>self</code> into the result …\nEncodes <code>data</code> as a prefixed hex string using lowercase …\nEncodes <code>input</code> as a hex string using lowercase characters …\nEncodes <code>input</code> as a hex string using uppercase characters …\nEncodes <code>data</code> as a hex string using uppercase characters.\nEncodes <code>data</code> as a prefixed hex string using uppercase …\nPrint an array of bytes into this buffer and return a …\nPrint a slice of bytes into this buffer and return a …\nPrint a slice of bytes into this buffer and return a …\nPrint an array of bytes into this buffer and return a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an instance of type <code>Self</code> from the given hex …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is a cheap operation; you don’t need to worry about …\nHex encoding with <code>serde</code>.\nSerializes <code>data</code> as hex string using lowercase characters.\nSerializes <code>data</code> as hex string using uppercase characters.\nCopies <code>self</code> into a new owned <code>String</code>.\nCopies <code>self</code> into a new <code>Vec</code>.\nModified from <code>hex</code>.\nDeserializes a hex string into raw bytes.\nSerializes <code>data</code> as hex string using lowercase characters.\nSerializes <code>data</code> as hex string using uppercase characters.\nThe associated error which can be returned from parsing.\nTypes that can be decoded from a hex string.\nEncoding values as hex string.\nEncoding values as hex string.\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result …\nEncode the hex strict representing <code>self</code> into the result …\nCreates an instance of type <code>Self</code> from the given hex …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nA view into a single entry in a map, which may either be …\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nAn occupied entry.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nA vacant entry.\nProvides in-place mutable access to an occupied entry …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA hash map implemented with quadratic probing and SIMD …\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a reference to this entry’s key.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nEnsures a value is in the entry by inserting, if empty, …\nThe default <code>Hasher</code> used by <code>RandomState</code>.\nA draining iterator over the entries of a <code>HashMap</code>.\nA view into a single entry in a map, which may either be …\nA draining, filtering iterator over the entries of a …\nA hash map implemented with quadratic probing and SIMD …\nAn owning iterator over the entries of a <code>HashMap</code>.\nAn owning iterator over the keys of a <code>HashMap</code>.\nAn owning iterator over the values of a <code>HashMap</code>.\nAn iterator over the entries of a <code>HashMap</code>.\nA mutable iterator over the entries of a <code>HashMap</code>.\nAn iterator over the keys of a <code>HashMap</code>.\nAn occupied entry.\nAn occupied entry.\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nThe error returned by <code>try_insert</code> when the key already …\n<code>RandomState</code> is the default state for <code>HashMap</code> types.\nA builder for computing where in a HashMap a key-value …\nA builder for computing where in a HashMap a key-value …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nA vacant entry.\nA vacant entry.\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nAn iterator over the values of a <code>HashMap</code>.\nA mutable iterator over the values of a <code>HashMap</code>.\nProvides in-place mutable access to an occupied entry …\nReturns the number of elements the map can hold without …\nClears the map, removing all key-value pairs. Keeps the …\nReturns <code>true</code> if the map contains a value for the specified …\nCreates an empty <code>HashMap&lt;K, V, S&gt;</code>, with the <code>Default</code> value …\nConstructs a new <code>RandomState</code>.\nCreates a new <code>DefaultHasher</code> using <code>new</code>. See its …\nClears the map, returning all key-value pairs as an …\nGets the given key’s corresponding entry in the map for …\nThe entry in the map that was already occupied.\nCreates an iterator which uses a closure to determine if …\nExamples\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>RawEntryMut</code> from the given hash.\nAccess an entry by hash.\nCreates a <code>RawEntryMut</code> from the given key.\nAccess an entry by key.\nCreates a <code>RawEntryMut</code> from the given key and its hash.\nAccess an entry by a key and its hash.\nReturns a reference to the value corresponding to the key.\nGets a reference to the value in the entry.\nGets a reference to the value in the entry.\nReturns the key-value pair corresponding to the supplied …\nGets a reference to the key and value in the entry.\nGets a mutable reference to the key and value in the entry.\nAttempts to get mutable references to <code>N</code> values in the map …\nAttempts to get mutable references to <code>N</code> values in the map …\nReturns a mutable reference to the value corresponding to …\nGets a mutable reference to the value in the entry.\nGets a mutable reference to the value in the entry.\nReturns a reference to the map’s <code>BuildHasher</code>.\nReturns a reference to the value corresponding to the …\nInserts a key-value pair into the map.\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the VacantEntry’s key, …\nSets the value of the entry, and returns the entry’s old …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nConverts the entry into a mutable reference to the key in …\nTake ownership of the key.\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the keys in …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the values in …\nReturns <code>true</code> if the map contains no elements.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all key-value pairs in arbitrary …\nGets a reference to the key in the entry.\nGets a reference to the key in the entry.\nGets a reference to the key that would be used when …\nGets a mutable reference to the key in the entry.\nAn iterator visiting all keys in arbitrary order. The …\nReturns the number of elements in the map.\nCreates an empty <code>HashMap</code>.\nConstructs a new <code>RandomState</code> that is initialized with …\nCreates a new <code>DefaultHasher</code>.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nCreates a raw immutable entry builder for the HashMap.\nCreates a raw entry builder for the HashMap.\nRemoves a key from the map, returning the value at the key …\nTakes the value out of the entry, and returns it.\nTakes the value out of the entry, and returns it.\nRemoves a key from the map, returning the stored key and …\nTake the ownership of the key and value from the map.\nTake the ownership of the key and value from the map.\nReplaces the entry, returning the old key and value. The …\nReplaces the key in the hash map with the key used to …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the map with a lower limit. It …\nShrinks the capacity of the map as much as possible. It …\nTries to insert a key-value pair into the map, and returns …\nTries to reserve capacity for at least <code>additional</code> more …\nThe value which was not inserted, because the entry was …\nAn iterator visiting all values in arbitrary order. The …\nAn iterator visiting all values mutably in arbitrary order.\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> which will use the given hash …\nA lazy iterator producing elements in the difference of …\nA draining iterator over the items of a <code>HashSet</code>.\nA draining, filtering iterator over the items of a <code>HashSet</code>.\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nA lazy iterator producing elements in the intersection of …\nAn owning iterator over the items of a <code>HashSet</code>.\nAn iterator over the items of a <code>HashSet</code>.\nA lazy iterator producing elements in the symmetric …\nA lazy iterator producing elements in the union of <code>HashSet</code>…\nReturns the intersection of <code>self</code> and <code>rhs</code> as a new …\nReturns the union of <code>self</code> and <code>rhs</code> as a new <code>HashSet&lt;T, S&gt;</code>.\nReturns the symmetric difference of <code>self</code> and <code>rhs</code> as a new …\nReturns the number of elements the set can hold without …\nClears the set, removing all values.\nOverwrites the contents of <code>self</code> with a clone of the …\nReturns <code>true</code> if the set contains a value.\nCreates an empty <code>HashSet&lt;T, S&gt;</code> with the <code>Default</code> value for …\nVisits the values representing the difference, i.e., the …\nClears the set, returning all elements as an iterator. …\nCreates an iterator which uses a closure to determine if a …\nReturns the argument unchanged.\nExamples\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value in the set, if any, that …\nInserts the given <code>value</code> into the set if it is not present, …\nInserts an owned copy of the given <code>value</code> into the set if …\nInserts a value computed from <code>f</code> into the set if the given …\nReturns a reference to the set’s <code>BuildHasher</code>.\nAdds a value to the set.\nVisits the values representing the intersection, i.e., the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nReturns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>. …\nReturns <code>true</code> if the set contains no elements.\nReturns <code>true</code> if the set is a subset of another, i.e., <code>other</code>…\nReturns <code>true</code> if the set is a superset of another, i.e., …\nAn iterator visiting all elements in arbitrary order. The …\nReturns the number of elements in the set.\nCreates an empty <code>HashSet</code>.\nRemoves a value from the set. Returns whether the value was\nAdds a value to the set, replacing the existing value, if …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the set with a lower limit. It …\nShrinks the capacity of the set as much as possible. It …\nReturns the difference of <code>self</code> and <code>rhs</code> as a new …\nVisits the values representing the symmetric difference, …\nRemoves and returns the value in the set, if any, that is …\nTries to reserve capacity for at least <code>additional</code> more …\nVisits the values representing the union, i.e., all the …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates a new empty hash set which will use the given …\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nError for <code>from_base_le</code> and <code>from_base_be</code>.\nError from <code>Uint::from_base_be</code>.\nA newtype wrapper around <code>Uint</code> that restricts operations to …\nError for <code>TryFrom&lt;Uint&gt;</code>.\nThe requested number base <code>.0</code> is less than two.\nThe provided digit <code>.0</code> is out of range for requested base <code>.1</code>…\nInvalid digit in string.\nInvalid radix, up to base 64 is supported.\nThe size of this integer type in 64-bit limbs.\n‘Not a number’ (NaN) can not be represented as Uint\nNumber is equal or larger than the target field modulus.\nThe value is too large to fit the target type.\nThe Uint value is too large for the target type.\nError for <code>from_str_radix</code>.\nError for <code>TryFrom&lt;Uint&gt;</code> for <code>ark_ff</code> and others.\nError for <code>TryFrom&lt;T&gt;</code> for <code>Uint</code>.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\nNegative values can not be represented as Uint.\nValue is too large to fit the Uint.\nThe value zero. This is the only value that exists in all …\n⚠️ Collection of bignum algorithms.\nType aliases for common bit sizes of <code>Uint</code> and <code>Bits</code>.\nSee <code>Uint::as_le_bytes</code> for documentation.\nSee <code>Uint::as_limbs</code> for documentation.\nSee <code>Uint::as_limbs_mut</code> for documentation.\nReturns a reference to the inner Uint.\nReturns a mutable reference to the inner Uint.\nSee <code>Uint::checked_shl</code> for documentation.\nSee <code>Uint::checked_shr</code> for documentation.\nCompile time for loops with a <code>const</code> variable for testing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSee <code>Uint::from_be_bytes</code> for documentation.\nSee <code>Uint::from_le_bytes</code> for documentation.\nSee <code>Uint::from_limbs</code> for documentation.\nSee <code>Uint::from_str_radix</code> for documentation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner Uint.\nSee <code>Uint::leading_ones</code> for documentation.\nSee <code>Uint::leading_zeros</code> for documentation.\nMask to apply to the highest limb to get the correct …\nNumber of bytes required to represent the given number of …\nNumber of <code>u64</code> limbs required to represent the given number …\nSee <code>Uint::overflowing_shl</code> for documentation.\nSee <code>Uint::overflowing_shr</code> for documentation.\nSee <code>Uint::reverse_bits</code> for documentation.\nSee <code>Uint::rotate_left</code> for documentation.\nSee <code>Uint::rotate_right</code> for documentation.\nSupport for external crates.\nSee <code>Uint::to_be_bytes</code> for documentation.\nSee <code>Uint::to_be_bytes_vec</code> for documentation.\nSee <code>Uint::to_le_bytes</code> for documentation.\nSee <code>Uint::trailing_ones</code> for documentation.\nSee <code>Uint::trailing_zeros</code> for documentation.\nSee <code>Uint::try_from_be_slice</code> for documentation.\nSee <code>Uint::try_from_le_slice</code> for documentation.\nSee <code>Uint::wrapping_shl</code> for documentation.\nSee <code>Uint::wrapping_shr</code> for documentation.\n⚠️ Lehmer update matrix\n<code>lhs += rhs + carry</code>\nComputes <code>lhs += a</code> and returns the carry.\n⚠️ Computes <code>result += a * b</code> and checks for overflow.\nComputes wrapping <code>lhs += a * b</code> when all arguments are the …\nComputes <code>lhs += a * b</code> and returns the carry.\nApplies the matrix to a <code>Uint</code>.\nApplies the matrix to a <code>u128</code>.\nCompare two <code>u64</code> slices in reverse order.\nReturns the matrix product <code>self * other</code>.\n⚠️ Collection of division algorithms.\n⚠️ Division with remainder.\nReturns the argument unchanged.\nCompute a Lehmer update matrix from two <code>Uint</code>s.\nCompute the Lehmer update matrix in full 64 bit precision.\nCompute the Lehmer update matrix for small values.\nCompute the largest valid Lehmer update matrix for a …\n⚠️ Lehmer’s GCD algorithms.\n⚠️ Lehmer’s extended GCD.\nCalls <code>U::from(self)</code>.\n⚠️ Modular inversion using extended GCD.\nComputes <code>lhs *= a</code> and returns the carry.\nSee Handbook of Applied Cryptography, Algorithm 14.32, p. …\n<code>lhs -= rhs - borrow</code>\nComputes <code>lhs -= a * b</code> and returns the borrow.\n⚠️ Division with remainder.\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Computes the quotient of a 192 bits divided by a …\nTODO: This implementation is off by one.\n⚠️ Compute single limb division.\n⚠️ Compute single limb normalized division.\n⚠️ Compute double limb division.\n⚠️ Compute double limb normalized division.\n⚠️ In-place Knuth long division with implicit …\n⚠️ In-place Knuth normalized long division with …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathtt{d}}} - …\n<code>Bits</code> for <code>0</code> bits.\n<code>Bits</code> for <code>1</code> bits.\n<code>Bits</code> for <code>1024</code> bits.\n<code>Bits</code> for <code>128</code> bits.\n<code>Bits</code> for <code>16</code> bits.\n<code>Bits</code> for <code>160</code> bits.\n<code>Bits</code> for <code>192</code> bits.\n<code>Bits</code> for <code>2048</code> bits.\n<code>Bits</code> for <code>256</code> bits.\n<code>Bits</code> for <code>32</code> bits.\n<code>Bits</code> for <code>320</code> bits.\n<code>Bits</code> for <code>384</code> bits.\n<code>Bits</code> for <code>4096</code> bits.\n<code>Bits</code> for <code>448</code> bits.\n<code>Bits</code> for <code>512</code> bits.\n<code>Bits</code> for <code>64</code> bits.\n<code>Bits</code> for <code>768</code> bits.\n<code>Bits</code> for <code>8</code> bits.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n<code>Uint</code> for <code>128</code> bits. Similar to <code>u128</code>.\n<code>Uint</code> for <code>16</code> bits. Similar to <code>u16</code>.\n<code>Uint</code> for <code>160</code> bits.\n<code>Uint</code> for <code>192</code> bits.\n<code>Uint</code> for <code>2048</code> bits.\n<code>Uint</code> for <code>256</code> bits.\n<code>Uint</code> for <code>32</code> bits. Similar to <code>u32</code>.\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n<code>Uint</code> for <code>512</code> bits.\n<code>Uint</code> for <code>64</code> bits. Similar to <code>u64</code>.\n<code>Uint</code> for <code>768</code> bits.\n<code>Uint</code> for <code>8</code> bits. Similar to <code>u8</code>.\nThe prefix used for hashing messages according to EIP-191.\nEther is equivalent to 1e18 wei.\nGwei is equivalent to 1e9 wei.\nSigned 256-bit integer.\nThe provided units are not recognized.\nKwei is equivalent to 1e3 wei.\nSimple <code>Keccak-256</code> hasher.\nThe largest unit.\nThe smallest unit.\nMwei is equivalent to 1e6 wei.\nPwei is equivalent to 1e15 wei.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nTwei is equivalent to 1e12 wei.\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nWei is equivalent to 1 wei.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the numeric value of the unit.\nReturns the absolute value of the number.\nReturns the signed value of the number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the number is negative.\nReturns <code>true</code> if the number is positive.\nReturns <code>true</code> if the number is signed.\nReturns <code>true</code> if the number is unsigned.\nReturns <code>true</code> if the number is zero.\nSimple interface to the <code>Keccak-256</code> hash function.\nCreates a new <code>Unit</code> instance, checking for overflow.\nCreates a new <code>Unit</code> instance.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nParses a decimal number and multiplies it with 10^units.\nTries to collect the elements of an iterator into a <code>Vec</code>.\nTries to create a <code>Vec</code> with the given capacity.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nBit-Array Type Definition\nMemory Bus Access Management\nStatically-Allocated, Fixed-Size, Bit Buffer\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nHeap-Allocated, Fixed-Size, Bit Buffer\nMemory Region Description\nBit-Field Memory Slots\nBit Indices\nConstructor Macros\nMemory Element Descriptions\nIn-Element Bit Ordering\nSymbol Export\nRaw Pointer Implementation\nBit-Addressable Memory Regions\nStorage Memory Description\nDynamically-Allocated, Adjustable-Size, Bit Buffer\nBit View Adapters\nBit-Level Access Instructions\nRead-Only Semivolatile Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nThe element type being guarded against improper mutation.\nThe memory-access type this guards.\nThe zero constant.\nClears bits within a memory element to <code>0</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the function that will write <code>value</code> into all bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverts bits within a memory element.\nLoads the value from memory, allowing for the possibility …\nSets bits within a memory element to <code>1</code>.\nWrites a value to one bit in a memory element, returning …\nBit-Precision Array Immediate\nBit-Array Iteration\nThe ordering of bits within an <code>A::Store</code> element.\nViews the remaining unyielded bits in the iterator.\nMutably views the remaining unyielded bits in the iterator.\nThe wrapped data buffer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConverts a bit-array into its iterator.\nFixed-Size, Heap-Allocated, Bit Slice\nAn iterator over a <code>BitBox</code>.\nBit-Slice Partitioning\nBit-Slice Element Partitioning\nIndicates that a bit-slice’s contents are entirely in …\nIndicates that a bit-slice’s contents are entirely in …\nPartially-Owned Memory Element\nIndicates that a bit-slice’s contents touch an element …\nIndicates that a bit-slice’s contents touch an element …\nGets the semantic head and tail indices that constrain …\nClears all bits governed by the partial-element to <code>0</code>.\nAttempts to unpack the bit-domain as an <code>Enclave</code> variant. …\nAttempts to unpack the bit-domain as an <code>Enclave</code> variant. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the starting index of the live bits in the element.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the element-wise <code>Domain</code> into the equivalent …\nConverts the partial element into a bit-slice over its …\nInverts the value of each bit governed by the …\nFetches the value stored through <code>self</code> and masks away extra …\nGets the bit-mask over all accessible bits.\nAttempts to unpack the bit-domain as a <code>Region</code> variant. …\nAttempts to unpack the bit-domain as a <code>Region</code> variant. …\nSets all bits governed by the partial-element to <code>1</code>.\nStores a value through <code>self</code> after masking away extra bits.\nPerforms a store operation on a partial-element whose bits …\nGets the ending index of the live bits in the element.\nAny bits that wholly-fill elements in the interior of the …\nAny bits that partially-fill the first element of the …\nAny bits that partially-fill the last element of the …\nAll fully-used elements in the bit-slice’s underlying …\nThe first element in the bit-slice’s underlying storage, …\nThe last element in the bit-slice’s underlying storage, …\nC-Style Bit-Field Access\nInteger Loading\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nInteger Storing\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nA full bit-mask with every bit set.\nOne-Bit-After Tail Index\nSemantic Bit Index\nBit Index Error\nMulti-Bit Selection Mask\nBit Position\nOne-Hot Bit Selection Mask\nThe inclusive maximum index within an <code>R</code> element.\nThe inclusive maximum tail within (or after) an <code>R</code> element.\nThe position value of the most significant bit in an <code>R</code> …\nThe inclusive minimum index within an <code>R</code> element.\nThe inclusive minimum tail within (or after) an <code>R</code> element.\nThe position value of the least significant bit in an <code>R</code> …\nAn empty bit-mask with every bit cleared.\nCreates a new mask with a selector bit activated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a selector bit into a mask.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemoves the index wrapper, leaving the internal counter.\nRemoves the error wrapper, leaving the internal counter.\nRemoves the tail wrapper, leaving the internal counter.\nRemoves the position wrapper, leaving the internal counter.\nRemoves the one-hot selection wrapper, leaving the …\nRemoves the mask wrapper, leaving the internal value.\nComputes the bit selector for <code>self</code> as an accessor mask.\nComputes the bit selector for <code>self</code> as an accessor mask.\nComputes a bit-mask for <code>self</code>. This is a type-cast.\nWraps a counter value as a known-good index into an <code>R</code> …\nWraps a counter value as a known-good tail of an <code>R</code> …\nWraps a counter value as a known-good position within an <code>R</code> …\nWraps a selector value as a known-good selection in an <code>R</code> …\nWraps any <code>R</code> value as a bit-mask.\nWraps a counter value as an assumed-good index into an <code>R</code> …\nWraps a counter value as an assumed-good position within …\nWraps a selector value as an assumed-good selection in an <code>R</code>…\nIncrements an index counter, wrapping at the back edge of …\nComputes the bit position corresponding to <code>self</code> under some …\nDecrements an index counter, wrapping at the front edge of …\nIterates over all indices between an inclusive start and …\nIterates over all possible index values.\nIterates over all possible selector values.\nIterates over all tail indices at and after an inclusive …\nComputes the bit selector corresponding to <code>self</code> under an …\nComputes the bit selector corresponding to <code>self</code>.\nTests if a mask contains a given selector bit.\nThe literal <code>!0</code>.\nRegister Descriptions\nThe number of bits required to store an index in the range …\nA mask over all bits that can be used as an index within …\nCounts the number of bits in a value of type <code>T</code>.\nBit Storage Calculator\nIn-Element Bit Ordering\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nMost-Significant-First Bit Traversal\nTranslates a semantic bit index into a real bit position.\nProduces a multi-bit selection mask from a range of …\nProduces a single-bit selection mask from a bit-index.\nComplete <code>BitOrder</code> Verification\nSingle-Type <code>BitOrder</code> Verification\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nImmutable Bit View\nMutable Bit View\nBit-Array Type Definition\nBit-Precision Array Immediate\nFixed-Size, Heap-Allocated, Bit Slice\nIn-Element Bit Ordering\nSingle-Bit Pointer\nBit-Pointer Range\nProxy Bit-Reference\nBit-Addressable Memory\nBit Storage\nBit-Precision Dynamic Array\nThe canonical dangling pointer. This selects the starting …\nThe canonical empty range. All ranges with zero length …\nAn empty bit-vector with no backing allocation.\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nThe inclusive maximum length of a <code>BitSlice&lt;_, T&gt;</code>.\nThe inclusive maximum length that a <code>[T]</code> slice can be for …\nThe element type used in the memory region underlying a …\nMost-Significant-First Bit Traversal\nThe underlying element type.\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nA bit-array with all bits initialized to zero.\nThe zero constant.\nThe zero constant.\nC-Style Bit-Field Access\nHelper trait for scalars and arrays, but not slices.\nBit View\nThe ordering of bits within an <code>A::Store</code> element.\nAdjusts a bit-pointer upwards in memory. This is …\nGets the address of the base storage element.\nComputes the offset (in bits) that needs to be applied to …\nProduces bit-slice view(s) with different underlying …\nProduces bit-slice view(s) with different underlying …\nTests if every bit is set to <code>1</code> in the bit-slice.\nTests if there is at least one bit set to <code>1</code> in the …\nMoves all the bits out of <code>other</code> into the back of <code>self</code>.\nGets a raw pointer to the zeroth bit of the bit-slice.\nCreates an unsafe shared bit-pointer to the start of the …\nViews the bit-slice as a half-open range of bit-pointers, …\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nExplicitly views the bit-array as a bit-slice.\nExplicitly views the bit-box as a bit-slice.\nExplicitly views the bit-vector as a bit-slice.\nProduces a proxy reference to the referent bit.\nGets a raw, write-capable pointer to the zeroth bit of the …\nCreates an unsafe writable bit-pointer to the start of the …\nViews the bit-slice as a half-open range of write-capable …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nExplicitly views the bit-array as a mutable bit-slice.\nExplicitly views the bit-box as a mutable bit-slice.\nExplicitly views the bit-vector as a mutable bit-slice.\nProduces a range of mutable bit-pointers to each bit in …\nReturns a mutable bit-slice containing the entire …\nProduces a range of bit-pointers to each bit in the …\nViews the type as a mutable slice of its elements.\nViews the bit-array as a mutable slice of its underlying …\nViews the bit-box as a mutable slice of its underlying …\nViews the bit-vector as a mutable slice of its underlying …\nViews the type as a slice of its elements.\nViews the bit-array as a slice of its underlying memory …\nViews the bit-box as a slice of its underlying memory …\nViews the bit-vector as a slice of its underlying memory …\nProduces a proxy reference to the referent bit.\nReturns a bit-slice containing the entire bit-array. …\nTranslates a semantic bit index into a real bit position.\nGets the <code>BitIdx</code> that selects the bit within the memory …\nPartitions a bit-slice into maybe-contended and …\nPartitions a mutable bit-slice into maybe-contended and …\nBoolean Arithmetic\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBoolean Arithmetic\nBit-Slice Region Constructor\nBit-Vector Constructor\nBoolean Arithmetic\nGets the allocation capacity, measured in bits.\nCasts to a <code>BitPtr</code> with a different storage parameter.\nIterates over non-overlapping subslices of a bit-slice.\nIterates over non-overlapping subslices of a bit-slice.\nIterates over non-overlapping mutable subslices of a …\nIterates over non-overlapping mutable subslices of a …\nEmpties the bit-vector.\nCopies the bits from <code>src</code> into <code>self</code>.\nCommits a bit into the proxied location.\nTests if a given bit-pointer is contained within the range.\nTests if the bit-slice contains the given sequence …\nCopies <code>count</code> bits from the region starting at <code>src</code> to the …\nCopies all bits from <code>src</code> into <code>self</code>, using batched …\nCopies <code>count</code> bits from the region starting at <code>src</code> to the …\nCopies <code>count</code> bits from <code>self</code> to <code>dest</code>. The source and …\nCopies <code>count</code> bits from <code>self</code> to <code>dest</code>. The source and …\nCopies a span of bits to another location in the bit-slice.\nCopies bits from one region of the bit-slice to another …\nCounts the number of bits set to <code>1</code> in the bit-slice …\nCounts the number of bits cleared to <code>0</code> in the bit-slice …\nThe wrapped data buffer.\nViews the underlying memory of a bit-slice, removing alias …\nViews the underlying memory of a bit-slice, removing alias …\nIterates over a portion of the bit-vector, <em>removing</em> all …\nRuns the destructor of the referent value.\nProduces an empty bit-slice with an arbitrary lifetime.\nProduces an empty bit-slice with an arbitrary lifetime.\nThe higher, exclusive, bound of the range. The bit to …\nTests if the bit-slice ends with the given sequence.\nAppends the contents of a bit-slice to a bit-vector.\nAppends a slice of <code>T</code> elements to a bit-vector.\nExtends <code>self</code> by copying an internal range of its bit-slice …\nFills the bit-slice with a given bit.\nSets the unused bits outside the <code>BitBox</code> buffer to a fixed …\nFills the bit-slice with bits produced by a generator …\nGets a reference to the first bit of the bit-slice, or <code>None</code>…\nGets a mutable reference to the first bit of the …\nFinds the index of the first bit in the bit-slice set to <code>1</code>.\nFinds the index of the first bit in the bit-slice cleared …\nEnsures that the allocated buffer has no dead bits between …\nEnsures that the live region of the bit-vector’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a bit-pointer into a proxy bit-reference.\nCopies a bit-slice region into a new bit-box allocation.\nCopies the contents of a bit-slice into a new heap …\nConverts a <code>Box&lt;[T]&gt;</code> into a <code>BitBox&lt;T, O&gt;</code>, in place.\nConstructs a shared <code>&amp;BitSlice</code> reference over a shared …\nConstructs a new bit-vector from a single element.\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over an …\nConstructs a mutable <code>BitPtr</code> to the zeroth bit in a single …\nConstructs a <code>BitPtr</code> to the zeroth bit in the zeroth …\nExplicitly converts a <code>Range&lt;BitPtr&gt;</code> into a <code>BitPtrRange</code>.\nConstructs a bit-box from a raw bit-slice pointer.\nConstructs a bit-vector handle from its constituent fields.\nConstructs a <code>BitPtr</code> to the zeroth bit in a single element.\nConstructs a <code>BitPtr</code> to the zeroth bit in the zeroth …\nConstructs a shared <code>&amp;BitSlice</code> reference over a slice of …\nConstructs a new bit-vector from a slice of memory …\nConstructs a mutable <code>BitPtr</code> to the zeroth bit in the …\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over a …\nConstructs a shared <code>&amp;BitSlice</code> over an element slice, …\nConstructs an exclusive <code>&amp;mut BitSlice</code> over an element …\nConverts a regular vector in-place into a bit-vector.\nGets a reference to a single bit or a subsection of the …\nReads a single bit out of the memory system according to …\nGets a mutable reference to a single bit or a subsection …\nGets a reference to a single bit or to a subsection of the …\nGets a mutable reference to a single bit or a subsection …\nLooks up a single bit by its semantic index.\nInserts a bit at a given position, shifting all bits after …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps <code>self</code> in a <code>BitArray</code>.\nDecays the bit-reference to an ordinary bit-pointer.\nConverts the bit-box into a bit-vector.\nConverts a bit-vector into a boxed bit-slice.\nConverts the bit-box back into an ordinary boxed element …\nRemoves the bit-array wrapper, returning the contained …\nExplicitly converts a <code>BitPtrRange</code> into a <code>Range&lt;BitPtr&gt;</code>.\nConsumes the bit-box, returning a raw bit-slice pointer.\nDecomposes a bit-vector into its constituent member fields.\nConverts a bit-vector into a <code>Vec</code> of its underlying storage.\nTests whether the array is empty.\nTests if the range is empty (the distance between …\nTests if the bit-slice is empty (length zero).\nTests if the bit-vector is empty.\nTests if a bit-pointer is the null value.\nProduces an iterator over each bit in the bit-slice.\nProduces a mutable iterator over each bit in the bit-slice.\nEnumerates the index of each bit in a bit-slice set to <code>1</code>.\nEnumerates the index of each bit in a bit-slice cleared to …\nGets a reference to the last bit of the bit-slice, or <code>None</code> …\nGets a mutable reference to the last bit of the bit-slice, …\nFinds the index of the last bit in the bit-slice set to <code>1</code>.\nFinds the index of the last bit in the bit-slice cleared …\nCounts the number of bits from the start of the bit-slice …\nCounts the number of bits from the start of the bit-slice …\nDeliberately leaks the allocated memory, returning an …\nDestroys the <code>BitVec</code> handle without destroying the …\nGets the length (in bits) of the bit-array.\nGets the number of bits in the bit-slice.\nGets the length of the bit-vector.\nInteger Loading\nBig-Endian Integer Loading\n<code>Lsb0</code> Big-Endian Integer Loading\n<code>Msb0</code> Big-Endian Integer Loading\nLittle-Endian Integer Loading\n<code>Lsb0</code> Little-Endian Integer Loading\n<code>Msb0</code> Little-Endian Integer Loading\nLoads a value out of the memory system according to the …\nProduces a multi-bit selection mask from a range of …\nWraps a raw memory value as a <code>BitStore</code> type.\nWraps an existing buffer as a bit-array.\nTries to construct a <code>BitPtr</code> from a memory location and a …\nConstructs a new, empty, bit-vector.\nConstructs a <code>BitPtr</code> from an address and head index, …\nTests if at least one bit is cleared to <code>0</code> in the bit-slice.\nTests if every bit is cleared to <code>0</code> in the bit-slice.\nCreates a new bit-pointer at a specified offset from the …\nCalculates the distance (in bits) between two bit-pointers.\nGets a raw pointer to the memory location containing the …\nGets a raw pointer to the memory element containing the …\nAttempts to remove the trailing bit from the bit-vector.\nAppends a single bit to the vector.\nDecomposes a bit-pointer into its element address and bit …\nIterates over non-overlapping subslices of a bit-slice, …\nIterates over non-overlapping subslices of a bit-slice, …\nIterates over non-overlapping mutable subslices of a …\nIterates over non-overlapping mutable subslices of a …\nReads the bit from <code>*self</code>.\nReads the bit from <code>*self</code> using an unaligned memory access.\nReads the bit from <code>*self</code> using a volatile load.\nRemoves a bit at a given position, shifting all bits after …\nCreates a bit-vector by repeating a bit-slice <code>n</code> times.\nCreates a new bit-vector by repeating a bit for the …\nMoves <code>src</code> into the referenced bit, returning the previous …\nReplaces the bit at <code>*self</code> with a new value, returning the …\nWrites a new value into a bit, and returns its previous …\nWrites a new value into a bit, returning the previous …\nEnsures that the bit-vector has allocation capacity for <em>at </em>…\nEnsures that the bit-vector has allocation capacity for <em>at </em>…\nResizes the bit-vector to a new length. New bits are …\nResizes the bit-vector to a new length, using a function …\nRetains only the bits that the predicate allows.\nReverses the order of bits in a bit-slice.\nRotates the contents of a bit-slice to the left (towards …\nRotates the contents of a bit-slice to the right (away …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nIterates over mutable subslices separated by bits that …\nIterates over mutable subslices separated by bits that …\nProduces a single-bit selection mask from a bit-index.\nWrites <code>value</code> into the proxy.\nWrites a new value into a single bit.\nWrites a new value into a single bit, using alias-safe …\nWrites a new value into a single bit, using alias-safe …\nOverwrites each element (visible in <code>.as_raw_mut_slice()</code>) …\nResizes a bit-vector to a new length.\nWrites a new value into a single bit, without bounds …\nSets the uninitialized bits of a bit-vector to a known …\nShifts the contents of a bit-slice “left” (towards the …\nShifts the contents of a bit-slice “right” (away from …\nReleases excess capacity back to the allocator.\nTests if at least one bit is set to <code>1</code>, and at least one …\nModifies <code>self.drain()</code> so that the removed bit-slice is …\nIterates over subslices separated by bits that match a …\nSplits a bit-slice in two parts at an index.\nSplits a mutable bit-slice in two parts at an index.\nSplits a bit-slice at an index, without bounds checking.\nSplits a mutable bit-slice at an index, without bounds …\nSplits the bit-slice into a reference to its first bit, …\nSplits the bit-slice into mutable references of its first …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nSplits the bit-slice into a reference to its last bit, and …\nSplits the bit-slice into mutable references to its last …\nIterates over mutable subslices separated by bits that …\nSplits the bit-vector in half at an index, moving …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nThe lower, inclusive, bound of the range. The bit to which …\nTests if the bit-slice begins with the given sequence.\nInteger Storing\nBig-Endian Integer Storing\n<code>Msb0</code> Big-Endian Integer Storing\n<code>Lsb0</code> Big-Endian Integer Storing\nLittle-Endian Integer Storing\n<code>Lsb0</code> Little-Endian Integer Storing\n<code>Msb0</code> Little-Endian Integer Storing\nStores a value into the memory system. This is only called …\nRemoves a prefix bit-slice, if present.\nRemoves a suffix bit-slice, if present.\nAdjusts a bit-pointer downwards in memory. This is …\nSwaps the bit values of two proxies.\nSwaps the bits at two mutable locations.\nExchanges the bit values at two indices.\nTakes a bit out of the bit-vector.\nSwaps two bits in a bit-slice, without bounds checking.\nSwaps the contents of two bit-slices.\nCopies a bit-slice into an owned bit-vector.\nRemoves write permissions from a bit-pointer.\nAdds write permissions to a bit-pointer.\nDecomposes a bit-pointer into its address and head-index …\nCounts the number of bits from the end of the bit-slice to …\nCounts the number of bits from the end of the bit-slice to …\nShortens the bit-vector, keeping the first <code>new_len</code> bits …\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to convert an ordinary boxed slice into a boxed …\nAttempts to construct a shared <code>&amp;BitSlice</code> reference over a …\nFallibly constructs a new bit-vector from a slice of …\nAttempts to construct an exclusive <code>&amp;mut BitSlice</code> reference …\nAttempts to convert a regular vector in-place into a …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nIterates over consecutive windowing subslices in a …\nAllocates a new, empty, bit-vector with space for at least …\nAdjusts a bit-pointer upwards in memory, using wrapping …\nCreates a new bit-pointer at a specified offset from the …\nAdjusts a bit-pointer downwards in memory, using wrapping …\nWrites a new bit into the given location.\nWrites a bit into memory, tolerating unaligned addresses.\nWrites a new bit using volatile I/O operations.\nSingle-Bit Pointer\nErrors produced by invalid bit-pointer components.\nBit-Pointer Range\nProxy Bit-Reference\nAn error produced when creating <code>BitSpan</code> encoded references.\nMarks whether this type contains mutability permissions …\nA basic <code>const</code> marker.\nThe error produced when an address is insufficiently …\nAttempted to construct a bit-pointer with an address not …\nThe base element pointer is not aligned.\nA basic <code>mut</code> marker.\nGeneralized mutability permissions.\nAttempted to construct a bit-pointer with the null element …\nA null pointer was provided.\nCounts the layers of <code>Frozen&lt;&gt;</code> wrapping around a base <code>Const</code> …\nOne of <code>*const</code> or <code>*mut</code>.\nAllow instances to be constructed generically.\nThe requested address is too high, and wraps to zero.\nThe requested length exceeds the <code>BitSpan</code> length ceiling.\nBit-Slice Pointer Construction\nBit-Slice Pointer Construction\nEnsures that an address is well-aligned to its referent …\nBit-wise <code>memcpy</code>\nBit-wise <code>memcpy</code>\nRemote Destructor\nThe higher, exclusive, bound of the range. The bit to …\nBit-Pointer Equality\nFreeze this type, wrapping it in a <code>const</code> marker that may …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBit-Pointer Hashing\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBit-Pointer Sentinel Value\nBit-Pointer Sentinel Value\nSingle-Bit Read\nSingle-Bit Unaligned Read\nSingle-Bit Volatile Read\nSingle-Bit Replacement\nRaw Bit-Slice Pointer Construction\nRaw Bit-Slice Pointer Construction\nThe lower, inclusive, bound of the range. The bit to which …\nBit Swap\nMany-Bit Swap\nThaw a previously-frozen type, removing its <code>Frozen</code> marker …\nSingle-Bit Write\nBit-wise <code>memset</code>\nBit-wise <code>memset</code>\nSingle-Bit Unaligned Write\nSingle-Bit Volatile Write\nAn iterator over <code>BitSlice</code> that yields <code>&amp;bool</code> directly.\nBit-Addressable Memory\nBit-Slice Indexing\nAn iterator over <code>BitSlice</code> that yields <code>bool</code> directly.\nShared Bit-Slice Chunking\nShared Bit-Slice Exact Chunking\nExclusive Bit-Slice Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nThe output type of immutable access.\nShared Bit-Slice Iteration\nExclusive Bit-Slice Iteration\nAnti-Aliasing Iterator Adapter\nBit Seeking\nBit Seeking\nThe output type of mutable access.\nShared Bit-Slice Reverse Chunking\nShared Bit-Slice Reverse Exact Chunking\nExclusive Bit-Slice Reverse Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nBit-Slice Windowing\nViews the currently unyielded bit-slice.\nViews the remaining bit-slice that has not yet been …\nAdapts the iterator to yield regular <code>&amp;bool</code> references …\nAdapts the iterator to yield <code>bool</code> values rather than the …\nYields <code>bool</code> values directly, rather than proxy references.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nImmutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nMutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nImmutably indexes into a bit-slice without doing any …\nMutably indexes into a bit-slice without doing any bounds …\nImmutably indexes into a bit-slice, panicking if <code>self</code> is …\nMutably indexes into a bit-slice, panicking if <code>self</code> is out …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nViews the underlying bit-slice as a subslice of the …\nConsumes the iterator, returning the remnant bit-slice …\nConsumes the iterator, returning the remnant bit-slice …\nSee <code>ChunksExactMut::into_remainder()</code>.\nSee <code>RChunksExactMut::into_remainder()</code>\nGets the remnant bit-slice that the iterator will not …\nGets the remnant bit-slice that the iterator will not …\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nTakes the remnant bit-slice out of the iterator.\nTakes the remnant bit-slice out of the iterator.\nSee <code>ChunksExactMut::take_remainder()</code>\nSee <code>RChunksExactMut::take_remainder()</code>\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nBit Storage\nThe element type used in the memory region underlying a …\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nReads a single bit out of the memory system according to …\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nStores a value into the memory system. This is only called …\nBit-Precision Dynamic Array\nDraining Iteration\nAn iterator over a <code>BitBox</code>.\nSplicing Iteration\nViews the remaining unyielded bits as a bit-slice.\nViews the unyielded bits remaining in the drain.\nViews the remaining unyielded bits as a mutable bit-slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImmutable Bit View\nMutable Bit View\nBit View\nHelper trait for scalars and arrays, but not slices.\nThe underlying element type.\nThe zero constant.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nWraps <code>self</code> in a <code>BitArray</code>.\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nEVM database interface.\nEVM database commit interface.\nEVM database interface.\nThe database error type.\nThe database error type.\nWraps a <code>DatabaseRef</code> to provide a <code>Database</code> implementation.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet block hash by block number\nGet block hash by block number\nGet block hash by block number.\nGet block hash by block number.\nGet account code by its hash\nGet account code by its hash")