searchState.loadedDescShard("revm", 2, "Get account code by its hash.\nGet account code by its hash.\nCommit changes to the database.\nDatabase that is split on State and BlockHash traits.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet basic account information.\nGet basic account information.\nBlockHash database component from <code>crate::db::Database</code> it …\nGet block hash by block number\nGet block hash by block number\nGet account code by its hash\nGet account code by its hash\nState database component from <code>crate::db::Database</code> it is …\nGet storage value of address at index.\nGet storage value of address at index.\nGet block hash by block number\nGet block hash by block number\nGet basic account information.\nGet basic account information.\nGet account code by its hash\nGet account code by its hash\nGet storage value of address at index.\nGet storage value of address at index.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nIndicates a failed recovery attempt where no valid address …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nCost of creating authorized account that was previously …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nOnly supported version is version 0x00.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nIndicates a failed recovery attempt where no valid address …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nOnly supported version is version 0x00.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nStructure holding block blob excess gas and it calculates …\nThe block environment.\nA transaction that calls a contract or transfer.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nCreate scheme of <code>CREATE2</code>.\nCreate scheme.\nEVM environment configuration.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nDo not perform bytecode analysis.\nTransaction destination\nThe transaction environment.\nA list of addresses and storage keys that the transaction …\nList of authorizations, that contains the signature that …\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe difficulty of the block.\nEvm environment.\nThe excess blob gas of the block.\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nHandler configuration fields.\nHandler configuration fields.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce of the transaction.\nThe number of ancestor blocks of this block (block height).\nBytecode that is created with CREATE/CREATE2 is by default …\nThe output of the randomness beacon provided by the beacon …\nSpecification identification.\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nConfiguration environment with the chain spec id.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nConfiguration environment.\nEvm environment.\nHandler configuration fields.\nHandler configuration fields.\nSpecification identification.\nBody size is more than specified in the header.\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nEVM Object Format (EOF) container.\nEOF container body.\nEOF decode errors.\nEOF Header containing\nInvalid number for code kind\nInvalid data kind\nInvalid EOF magic number.\nInvalid initcode size.\nInvalid EOF version.\nInvalid kind after code\nInvalid terminal code\nInvalid number for types kind\nInvalid types section data.\nInvalid types section size.\nMismatch of code and types sizes.\nShort body while processing EOF.\nShort input while processing EOF.\nThere should be at least one size.\nMissing size.\nInvalid code number.\nInvalid container number.\nTypes section that contains stack information for matching …\nInvalid number of code sections.\nSize cant be zero\nReturns body size. It is sum of code sizes, container …\nReturns the code section at the given index.\nSizes of EOF code section. Code size can’t be zero.\nEOF Container size. Container size can be zero.\nEOF data size.\nReturn index where data size starts. Data size is two …\nDecodes an EOF container body from the given buffer and …\nDecodes EOF header from binary form.\nDecode the section from the input.\nEncodes this body into the given buffer.\nEncodes EOF header into binary form.\nEncode the section into the buffer.\nReturns raw size of the EOF.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ninputs - 1 byte - <code>0x00-0x7F</code> number of stack elements the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an EOF container from this body.\nCalculates the difference between the number of input and …\nTrue if section is non-returning.\nmax_stack_height - 2 bytes - <code>0x0000-0x03FF</code> maximum number …\nReturns new <code>TypesSection</code> with the given inputs, outputs, …\noutputs - 1 byte - <code>0x00-0x80</code> number of stack elements the …\nLength of the header in bytes.\nsum code sizes\nsum container sizes\nReturns number of types.\nSize of EOF types section. types section includes num of …\nValidate the section.\nCustom trusted setup.\nDefault mainnet trusted setup\nKZG Settings that allow us to specify a custom trusted …\nStores the setup and parameters needed for computing KZG …\nA map of valid <code>jump</code> destinations.\nLegacy analyzed\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nSimilar to Standard but takes reference to environment.\nContains the error value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nOutput bytes.\nGas used by the precompile.\nAccess list is not supported for blocks before the Berlin …\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\nBlob transaction can’t be a create transaction. <code>to</code> must …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCustom error.\nDatabase error.\nEOF Subroutine stack overflow\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHeader validation error.\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nTransaction validation error.\nTransaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nOutput of a transaction execution.\nOverflow payment in transaction.\nPrecompile error.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction validation error.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nThe specification ID.\nSpecification IDs and their activation block.\nReturns <code>true</code> if the given specification ID is enabled in …\nAccountInfo account information.\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\nStructure used for EIP-1153 transient storage.\nAccount balance.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nAccount nonce.\nOriginal value of the storage slot.\nPresent value of the storage slot.\nAccount status flags.\nStorage cache\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nSimple interface to the <code>Keccak-256</code> hash function.\nConverts a boolean to a left-padded <code>B256</code> value.\nConverts a boolean to a left-padded 32-byte <code>Bytes</code> value.\nLeft-pads the given slice with zeroes until <code>LEN</code>.\nLeft-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice with zeroes until <code>LEN</code>.\nRight-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>LEN</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>len</code>.\nAccessList as defined in EIP-2930\nA list of addresses and storage keys that the transaction …\nAccess list is not supported for blocks before the Berlin …\nAccountInfo account information.\nAn Ethereum address, 20 bytes in length.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\n32-byte fixed byte-array type.\nControls the maximum rate of change for blob gas price.\nControls the maximum rate of change for blob gas price …\nEIP-2935: Serve historical block hashes from state\nEIP-2935: Serve historical block hashes from state\nNumber of block hashes that EVM can access in the past …\nBlob transaction can’t be a create transaction. <code>to</code> must …\nStructure holding block blob excess gas and it calculates …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nThe block environment.\nState of the <code>Bytecode</code> analysis.\nEOF decode errors.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nA transaction that calls a contract or transfer.\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nA transaction that creates a contract.\nCreate scheme of <code>CREATE2</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCreate scheme.\nCustom trusted setup.\nCustom error.\nDatabase error.\nDefault mainnet trusted setup\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEOF Subroutine stack overflow\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEIP-7702 delegated bytecode\nEIP-7702 decode error\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nEVM environment configuration.\nSimilar to Standard but takes reference to environment.\nKZG Settings that allow us to specify a custom trusted …\nEvm environment with the chain spec id.\nEVM Object Format (EOF) container.\nEthereum Object Format\nEOF decode error\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\nContains the error value\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nA byte array of fixed length (<code>[u8; N]</code>).\nGas consumption of a single data blob (== blob byte size).\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHandler configuration fields. It is used to configure the …\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nHeader validation error.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\nIndicates a failed recovery attempt where no valid address …\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nTransaction validation error.\nA map of valid <code>jump</code> destinations.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nStores the setup and parameters needed for computing KZG …\nTransaction account does not have enough amount of ether …\nThe bytecode has been analyzed for valid jump destinations.\nLegacy analyzed\nNo analysis has been performed.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nMinimum gas price for data blobs.\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nOutput of a transaction execution.\nOverflow payment in transaction.\nThe address of precompile 3, which is handled specially in …\nPrecompile and its handlers.\nPrecompile error.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\n<code>prevrandao</code> is not set for Merge and above.\nAn Ethereum ECDSA signature.\nWhen using the EIP-1559 fee model introduced in the London …\nDo not perform bytecode analysis.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nThe specification ID.\nA signed EIP-7702 authorization.\nSpecification IDs and their activation block.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction destination\nTransaction validation error.\nStructure used for EIP-1153 transient storage.\nThe transaction environment.\nThe <code>to</code> field of a transaction. Either a target address, or …\n256-bit unsigned integer type, consisting of 4, 64-bit …\nOnly supported version is version 0x00.\nFirst version of the blob.\nIndicates a successfully recovered authority address.\nA list of addresses and storage keys that the transaction …\nAccount addresses that would be loaded at the start of …\nThe address of the authorization.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nList of authorizations, that contains the signature that …\nConverts a sequence of string literals containing …\nAccount balance.\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nOutput bytes.\nConverts a sequence of string literals containing …\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nThe chain ID of the authorization.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe plain data.\nThe log data.\nThe difficulty of the block.\nReturns <code>true</code> if the given specification ID is enabled in …\nEvm environment.\nThe excess blob gas of the block.\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nConverts a sequence of string literals containing …\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nGas used by the precompile.\nHandler configuration fields.\nHandler configuration fields.\nMacro for converting sequence of string literals …\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nSimple interface to the <code>Keccak-256</code> hash function.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce for the authorization.\nThe nonce of the transaction.\nAccount nonce.\nThe number of ancestor blocks of this block (block height).\nOriginal value of the storage slot.\nBytecode that is created with CREATE/CREATE2 is by default …\nPresent value of the storage slot.\nThe output of the randomness beacon provided by the beacon …\nStatus of execution\nSpecification identification.\nState that got updated\nAccount status flags.\nStorage cache\nKeys of storage that would be loaded at the start of …\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nHalting will spend all the gas, and will be equal to …\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n16-byte fixed byte-array type.\n20-byte fixed byte-array type.\n32-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe error type that is returned when conversion to or from …\nA block hash.\nA block number.\nA block timestamp.\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nChain identifier type (introduced in EIP-155).\nA transaction that creates a contract.\nExplicit V value. May be EIP-155 modified.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nSimple <code>Keccak-256</code> hasher.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nLess than zero.\nNon-EIP155. 27 or 28.\nThe parity of the signature, stored as either a V value …\nParity flag. True for odd.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nAn Ethereum ECDSA signature.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nSolidity contract functions are addressed using the first …\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe <code>to</code> field of a transaction. Either a target address, or …\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n128-bit unsigned integer type, consisting of 2, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nThe plain data.\nThe log data.\nHash a message according to EIP-191 (version <code>0x01</code>).\nConverts a sequence of string literals containing …\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nHex literal macro implementation.\nConsume and convert into a <code>LogData</code> object.\nSimple interface to the <code>Keccak-256</code> hash function.\nCompute the logs bloom filter for the given logs.\nRe-exports of map types and utilities.\nAttempts to normalize the v value to a boolean parity …\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nApplies EIP-155.\nConvert into a <code>LogData</code> object.\nTries to create a <code>Vec</code> containing the arguments.\nCommon Ethereum utilities.\nWrap a fixed-size byte array in a newtype, delegating all …\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\nMacro for converting sequence of string literals …\nA correctly sized stack allocation for the formatted bytes …\nThe associated error which can be returned from parsing.\nTypes that can be decoded from a hex string.\nThe error type for decoding a hex string into <code>Vec&lt;u8&gt;</code> or …\nThe table of lowercase characters used for hex encoding.\nThe table of uppercase characters used for hex encoding.\nThe lookup table of hex byte to value, used for hex …\nAn invalid character was found. Valid ones are: <code>0...9</code>, …\nIf the hex string is decoded into a fixed sized container, …\nRepresents an invalid value in the <code>HEX_DECODE_LUT</code> table.\nA hex string’s length needs to be even, as two digits …\nEncoding values as hex string.\nEncoding values as hex string.\nReturns <code>true</code> if the input is a valid hex string and can be …\nReturns <code>true</code> if the input is a valid hex string.\nReturns <code>true</code> if the input is a valid hex string and can be …\nReturns <code>true</code> if the input is a valid hex string.\nDecode a hex string into a fixed-length byte-array.\nEncodes <code>input</code> as a hex string into a <code>Buffer</code>.\nDecodes a hex string into raw bytes.\nDecode a hex string into a fixed-length byte-array.\nDecode a hex string into a mutable bytes slice.\nDeserializes a hex string into raw bytes.\nEncodes <code>data</code> as a hex string using lowercase characters.\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result …\nEncode the hex strict representing <code>self</code> into the result …\nEncodes <code>data</code> as a prefixed hex string using lowercase …\nEncodes <code>input</code> as a hex string using lowercase characters …\nEncodes <code>input</code> as a hex string using uppercase characters …\nEncodes <code>data</code> as a hex string using uppercase characters.\nEncodes <code>data</code> as a prefixed hex string using uppercase …\nCreates an instance of type <code>Self</code> from the given hex …\nHex encoding with <code>serde</code>.\nSerializes <code>data</code> as hex string using lowercase characters.\nSerializes <code>data</code> as hex string using uppercase characters.\nModified from <code>hex</code>.\nDeserializes a hex string into raw bytes.\nSerializes <code>data</code> as hex string using lowercase characters.\nSerializes <code>data</code> as hex string using uppercase characters.\nThe associated error which can be returned from parsing.\nTypes that can be decoded from a hex string.\nEncoding values as hex string.\nEncoding values as hex string.\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result. …\nEncode the hex strict representing <code>self</code> into the result …\nEncode the hex strict representing <code>self</code> into the result …\nCreates an instance of type <code>Self</code> from the given hex …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nA view into a single entry in a map, which may either be …\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nAn occupied entry.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nA vacant entry.\nA hash map implemented with quadratic probing and SIMD …\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nThe default <code>Hasher</code> used by <code>RandomState</code>.\nA draining iterator over the entries of a <code>HashMap</code>.\nA view into a single entry in a map, which may either be …\nA draining, filtering iterator over the entries of a …\nA hash map implemented with quadratic probing and SIMD …\nAn owning iterator over the entries of a <code>HashMap</code>.\nAn owning iterator over the keys of a <code>HashMap</code>.\nAn owning iterator over the values of a <code>HashMap</code>.\nAn iterator over the entries of a <code>HashMap</code>.\nA mutable iterator over the entries of a <code>HashMap</code>.\nAn iterator over the keys of a <code>HashMap</code>.\nAn occupied entry.\nAn occupied entry.\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nThe error returned by <code>try_insert</code> when the key already …\n<code>RandomState</code> is the default state for <code>HashMap</code> types.\nA builder for computing where in a HashMap a key-value …\nA builder for computing where in a HashMap a key-value …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nA vacant entry.\nA vacant entry.\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nAn iterator over the values of a <code>HashMap</code>.\nA mutable iterator over the values of a <code>HashMap</code>.\nThe entry in the map that was already occupied.\nThe value which was not inserted, because the entry was …\nA lazy iterator producing elements in the difference of …\nA draining iterator over the items of a <code>HashSet</code>.\nA draining, filtering iterator over the items of a <code>HashSet</code>.\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nA lazy iterator producing elements in the intersection of …\nAn owning iterator over the items of a <code>HashSet</code>.\nAn iterator over the items of a <code>HashSet</code>.\nA lazy iterator producing elements in the symmetric …\nA lazy iterator producing elements in the union of <code>HashSet</code>…\nError for <code>from_base_le</code> and <code>from_base_be</code>.\nError from <code>Uint::from_base_be</code>.\nA newtype wrapper around <code>Uint</code> that restricts operations to …\nError for <code>TryFrom&lt;Uint&gt;</code>.\nThe requested number base <code>.0</code> is less than two.\nThe provided digit <code>.0</code> is out of range for requested base <code>.1</code>…\nInvalid digit in string.\nInvalid radix, up to base 64 is supported.\n‘Not a number’ (NaN) can not be represented as Uint\nNumber is equal or larger than the target field modulus.\nThe value is too large to fit the target type.\nThe Uint value is too large for the target type.\nError for <code>from_str_radix</code>.\nError for <code>TryFrom&lt;Uint&gt;</code> for <code>ark_ff</code> and others.\nError for <code>TryFrom&lt;T&gt;</code> for <code>Uint</code>.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\nNegative values can not be represented as Uint.\nValue is too large to fit the Uint.\n⚠️ Collection of bignum algorithms.\nType aliases for common bit sizes of <code>Uint</code> and <code>Bits</code>.\nCompile time for loops with a <code>const</code> variable for testing.\nMask to apply to the highest limb to get the correct …\nNumber of bytes required to represent the given number of …\nNumber of <code>u64</code> limbs required to represent the given number …\nSupport for external crates.\n⚠️ Lehmer update matrix\n<code>lhs += rhs + carry</code>\nComputes <code>lhs += a</code> and returns the carry.\n⚠️ Computes <code>result += a * b</code> and checks for overflow.\nComputes wrapping <code>lhs += a * b</code> when all arguments are the …\nComputes <code>lhs += a * b</code> and returns the carry.\nCompare two <code>u64</code> slices in reverse order.\n⚠️ Collection of division algorithms.\n⚠️ Division with remainder.\n⚠️ Lehmer’s GCD algorithms.\n⚠️ Lehmer’s extended GCD.\n⚠️ Modular inversion using extended GCD.\nComputes <code>lhs *= a</code> and returns the carry.\nSee Handbook of Applied Cryptography, Algorithm 14.32, p. …\n<code>lhs -= rhs - borrow</code>\nComputes <code>lhs -= a * b</code> and returns the borrow.\n⚠️ Division with remainder.\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Computes the quotient of a 192 bits divided by a …\nTODO: This implementation is off by one.\n⚠️ Compute single limb division.\n⚠️ Compute single limb normalized division.\n⚠️ Compute double limb division.\n⚠️ Compute double limb normalized division.\n⚠️ In-place Knuth long division with implicit …\n⚠️ In-place Knuth normalized long division with …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathtt{d}}} - …\n<code>Bits</code> for <code>0</code> bits.\n<code>Bits</code> for <code>1</code> bits.\n<code>Bits</code> for <code>1024</code> bits.\n<code>Bits</code> for <code>128</code> bits.\n<code>Bits</code> for <code>16</code> bits.\n<code>Bits</code> for <code>160</code> bits.\n<code>Bits</code> for <code>192</code> bits.\n<code>Bits</code> for <code>2048</code> bits.\n<code>Bits</code> for <code>256</code> bits.\n<code>Bits</code> for <code>32</code> bits.\n<code>Bits</code> for <code>320</code> bits.\n<code>Bits</code> for <code>384</code> bits.\n<code>Bits</code> for <code>4096</code> bits.\n<code>Bits</code> for <code>448</code> bits.\n<code>Bits</code> for <code>512</code> bits.\n<code>Bits</code> for <code>64</code> bits.\n<code>Bits</code> for <code>768</code> bits.\n<code>Bits</code> for <code>8</code> bits.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n<code>Uint</code> for <code>128</code> bits. Similar to <code>u128</code>.\n<code>Uint</code> for <code>16</code> bits. Similar to <code>u16</code>.\n<code>Uint</code> for <code>160</code> bits.\n<code>Uint</code> for <code>192</code> bits.\n<code>Uint</code> for <code>2048</code> bits.\n<code>Uint</code> for <code>256</code> bits.\n<code>Uint</code> for <code>32</code> bits. Similar to <code>u32</code>.\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n<code>Uint</code> for <code>512</code> bits.\n<code>Uint</code> for <code>64</code> bits. Similar to <code>u64</code>.\n<code>Uint</code> for <code>768</code> bits.\n<code>Uint</code> for <code>8</code> bits. Similar to <code>u8</code>.\nThe prefix used for hashing messages according to EIP-191.\nSigned 256-bit integer.\nThe provided units are not recognized.\nSimple <code>Keccak-256</code> hasher.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nSimple interface to the <code>Keccak-256</code> hash function.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nTries to collect the elements of an iterator into a <code>Vec</code>.\nTries to create a <code>Vec</code> with the given capacity.\nBit-Array Type Definition\nMemory Bus Access Management\nStatically-Allocated, Fixed-Size, Bit Buffer\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nHeap-Allocated, Fixed-Size, Bit Buffer\nMemory Region Description\nBit-Field Memory Slots\nBit Indices\nConstructor Macros\nMemory Element Descriptions\nIn-Element Bit Ordering\nSymbol Export\nRaw Pointer Implementation\nBit-Addressable Memory Regions\nStorage Memory Description\nDynamically-Allocated, Adjustable-Size, Bit Buffer\nBit View Adapters\nBit-Level Access Instructions\nRead-Only Semivolatile Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nThe element type being guarded against improper mutation.\nThe memory-access type this guards.\nThe zero constant.\nClears bits within a memory element to <code>0</code>.\nGets the function that will write <code>value</code> into all bits …\nInverts bits within a memory element.\nLoads the value from memory, allowing for the possibility …\nSets bits within a memory element to <code>1</code>.\nWrites a value to one bit in a memory element, returning …\nBit-Precision Array Immediate\nBit-Array Iteration\nThe ordering of bits within an <code>A::Store</code> element.\nThe wrapped data buffer.\nFixed-Size, Heap-Allocated, Bit Slice\nAn iterator over a <code>BitBox</code>.\nBit-Slice Partitioning\nBit-Slice Element Partitioning\nIndicates that a bit-slice’s contents are entirely in …\nIndicates that a bit-slice’s contents are entirely in …\nPartially-Owned Memory Element\nIndicates that a bit-slice’s contents touch an element …\nIndicates that a bit-slice’s contents touch an element …\nAny bits that wholly-fill elements in the interior of the …\nAny bits that partially-fill the first element of the …\nAny bits that partially-fill the last element of the …\nAll fully-used elements in the bit-slice’s underlying …\nThe first element in the bit-slice’s underlying storage, …\nThe last element in the bit-slice’s underlying storage, …\nC-Style Bit-Field Access\nInteger Loading\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nInteger Storing\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nOne-Bit-After Tail Index\nSemantic Bit Index\nBit Index Error\nMulti-Bit Selection Mask\nBit Position\nOne-Hot Bit Selection Mask\nThe literal <code>!0</code>.\nRegister Descriptions\nThe number of bits required to store an index in the range …\nA mask over all bits that can be used as an index within …\nCounts the number of bits in a value of type <code>T</code>.\nBit Storage Calculator\nIn-Element Bit Ordering\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nMost-Significant-First Bit Traversal\nTranslates a semantic bit index into a real bit position.\nProduces a multi-bit selection mask from a range of …\nProduces a single-bit selection mask from a bit-index.\nComplete <code>BitOrder</code> Verification\nSingle-Type <code>BitOrder</code> Verification\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nImmutable Bit View\nMutable Bit View\nBit-Array Type Definition\nBit-Precision Array Immediate\nFixed-Size, Heap-Allocated, Bit Slice\nIn-Element Bit Ordering\nSingle-Bit Pointer\nBit-Pointer Range\nProxy Bit-Reference\nBit-Addressable Memory\nBit Storage\nBit-Precision Dynamic Array\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nThe element type used in the memory region underlying a …\nMost-Significant-First Bit Traversal\nThe underlying element type.\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nThe zero constant.\nBit View\nHelper trait for scalars and arrays, but not slices.\nC-Style Bit-Field Access\nThe ordering of bits within an <code>A::Store</code> element.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nTranslates a semantic bit index into a real bit position.\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nThe wrapped data buffer.\nThe higher, exclusive, bound of the range. The bit to …\nReads a single bit out of the memory system according to …\nWraps <code>self</code> in a <code>BitArray</code>.\nInteger Loading\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nLoads a value out of the memory system according to the …\nProduces a multi-bit selection mask from a range of …\nWraps a raw memory value as a <code>BitStore</code> type.\nProduces a single-bit selection mask from a bit-index.\nThe lower, inclusive, bound of the range. The bit to which …\nInteger Storing\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nStores a value into the memory system. This is only called …\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nSingle-Bit Pointer\nErrors produced by invalid bit-pointer components.\nBit-Pointer Range\nProxy Bit-Reference\nAn error produced when creating <code>BitSpan</code> encoded references.\nMarks whether this type contains mutability permissions …\nA basic <code>const</code> marker.\nThe error produced when an address is insufficiently …\nAttempted to construct a bit-pointer with an address not …\nThe base element pointer is not aligned.\nA basic <code>mut</code> marker.\nGeneralized mutability permissions.\nAttempted to construct a bit-pointer with the null element …\nA null pointer was provided.\nCounts the layers of <code>Frozen&lt;&gt;</code> wrapping around a base <code>Const</code> …\nOne of <code>*const</code> or <code>*mut</code>.\nAllow instances to be constructed generically.\nThe requested address is too high, and wraps to zero.\nThe requested length exceeds the <code>BitSpan</code> length ceiling.\nBit-Slice Pointer Construction\nBit-Slice Pointer Construction\nEnsures that an address is well-aligned to its referent …\nBit-wise <code>memcpy</code>\nBit-wise <code>memcpy</code>\nRemote Destructor\nThe higher, exclusive, bound of the range. The bit to …\nBit-Pointer Equality\nFreeze this type, wrapping it in a <code>const</code> marker that may …\nBit-Pointer Hashing\nBit-Pointer Sentinel Value\nBit-Pointer Sentinel Value\nSingle-Bit Read\nSingle-Bit Unaligned Read\nSingle-Bit Volatile Read\nSingle-Bit Replacement\nRaw Bit-Slice Pointer Construction\nRaw Bit-Slice Pointer Construction\nThe lower, inclusive, bound of the range. The bit to which …\nBit Swap\nMany-Bit Swap\nThaw a previously-frozen type, removing its <code>Frozen</code> marker …\nSingle-Bit Write\nBit-wise <code>memset</code>\nBit-wise <code>memset</code>\nSingle-Bit Unaligned Write\nSingle-Bit Volatile Write\nAn iterator over <code>BitSlice</code> that yields <code>&amp;bool</code> directly.\nBit-Addressable Memory\nBit-Slice Indexing\nAn iterator over <code>BitSlice</code> that yields <code>bool</code> directly.\nShared Bit-Slice Chunking\nShared Bit-Slice Exact Chunking\nExclusive Bit-Slice Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nThe output type of immutable access.\nShared Bit-Slice Iteration\nExclusive Bit-Slice Iteration\nAnti-Aliasing Iterator Adapter\nBit Seeking\nBit Seeking\nThe output type of mutable access.\nShared Bit-Slice Reverse Chunking\nShared Bit-Slice Reverse Exact Chunking\nExclusive Bit-Slice Reverse Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nBit-Slice Windowing\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nImmutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nMutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nImmutably indexes into a bit-slice without doing any …\nMutably indexes into a bit-slice without doing any bounds …\nImmutably indexes into a bit-slice, panicking if <code>self</code> is …\nMutably indexes into a bit-slice, panicking if <code>self</code> is out …\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nBit Storage\nThe element type used in the memory region underlying a …\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nReads a single bit out of the memory system according to …\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nStores a value into the memory system. This is only called …\nBit-Precision Dynamic Array\nDraining Iteration\nAn iterator over a <code>BitBox</code>.\nSplicing Iteration\nImmutable Bit View\nMutable Bit View\nBit View\nHelper trait for scalars and arrays, but not slices.\nThe underlying element type.\nThe zero constant.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nWraps <code>self</code> in a <code>BitArray</code>.\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nEVM database interface.\nEVM database commit interface.\nEVM database interface.\nThe database error type.\nThe database error type.\nWraps a <code>DatabaseRef</code> to provide a <code>Database</code> implementation.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet block hash by block number\nGet block hash by block number\nGet block hash by block number.\nGet block hash by block number.\nGet account code by its hash\nGet account code by its hash\nGet account code by its hash.\nGet account code by its hash.\nCommit changes to the database.\nDatabase that is split on State and BlockHash traits.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet basic account information.\nGet basic account information.\nBlockHash database component from <code>crate::db::Database</code> it …\nGet block hash by block number\nGet block hash by block number\nGet account code by its hash\nGet account code by its hash\nState database component from <code>crate::db::Database</code> it is …\nGet storage value of address at index.\nGet storage value of address at index.\nGet block hash by block number\nGet block hash by block number\nGet basic account information.\nGet basic account information.\nGet account code by its hash\nGet account code by its hash\nGet storage value of address at index.\nGet storage value of address at index.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nIndicates a failed recovery attempt where no valid address …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nCost of creating authorized account that was previously …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nOnly supported version is version 0x00.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nIndicates a failed recovery attempt where no valid address …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nOnly supported version is version 0x00.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nStructure holding block blob excess gas and it calculates …\nThe block environment.\nA transaction that calls a contract or transfer.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nCreate scheme of <code>CREATE2</code>.\nCreate scheme.\nEVM environment configuration.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nDo not perform bytecode analysis.\nTransaction destination\nThe transaction environment.\nA list of addresses and storage keys that the transaction …\nList of authorizations, that contains the signature that …\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe difficulty of the block.\nEvm environment.\nThe excess blob gas of the block.\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nHandler configuration fields.\nHandler configuration fields.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce of the transaction.\nThe number of ancestor blocks of this block (block height).\nBytecode that is created with CREATE/CREATE2 is by default …\nThe output of the randomness beacon provided by the beacon …\nSpecification identification.\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nConfiguration environment with the chain spec id.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nConfiguration environment.\nEvm environment.\nHandler configuration fields.\nHandler configuration fields.\nSpecification identification.\nBody size is more than specified in the header.\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nEVM Object Format (EOF) container.\nEOF container body.\nEOF decode errors.\nEOF Header containing\nInvalid number for code kind\nInvalid data kind\nInvalid EOF magic number.\nInvalid initcode size.\nInvalid EOF version.\nInvalid kind after code\nInvalid terminal code\nInvalid number for types kind\nInvalid types section data.\nInvalid types section size.\nMismatch of code and types sizes.\nShort body while processing EOF.\nShort input while processing EOF.\nThere should be at least one size.\nMissing size.\nInvalid code number.\nInvalid container number.\nTypes section that contains stack information for matching …\nInvalid number of code sections.\nSize cant be zero\nSizes of EOF code section. Code size can’t be zero.\nEOF Container size. Container size can be zero.\nEOF data size.\ninputs - 1 byte - <code>0x00-0x7F</code> number of stack elements the …\nmax_stack_height - 2 bytes - <code>0x0000-0x03FF</code> maximum number …\noutputs - 1 byte - <code>0x00-0x80</code> number of stack elements the …\nsum code sizes\nsum container sizes\nSize of EOF types section. types section includes num of …\nCustom trusted setup.\nDefault mainnet trusted setup\nKZG Settings that allow us to specify a custom trusted …\nStores the setup and parameters needed for computing KZG …\nA map of valid <code>jump</code> destinations.\nLegacy analyzed\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nSimilar to Standard but takes reference to environment.\nContains the error value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nOutput bytes.\nGas used by the precompile.\nAccess list is not supported for blocks before the Berlin …\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\nBlob transaction can’t be a create transaction. <code>to</code> must …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCustom error.\nDatabase error.\nEOF Subroutine stack overflow\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHeader validation error.\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nTransaction validation error.\nTransaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nOutput of a transaction execution.\nOverflow payment in transaction.\nPrecompile error.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction validation error.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nThe specification ID.\nSpecification IDs and their activation block.\nReturns <code>true</code> if the given specification ID is enabled in …\nAccountInfo account information.\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\nStructure used for EIP-1153 transient storage.\nAccount balance.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nAccount nonce.\nOriginal value of the storage slot.\nPresent value of the storage slot.\nAccount status flags.\nStorage cache\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nSimple interface to the <code>Keccak-256</code> hash function.")